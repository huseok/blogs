(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{495:function(v,t,_){"use strict";_.r(t);var a=_(2),r=Object(a.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"jvm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[v._v("#")]),v._v(" JVM")]),v._v(" "),t("h2",{attrs:{id:"jvm-运行时数据区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm-运行时数据区"}},[v._v("#")]),v._v(" JVM 运行时数据区")]),v._v(" "),t("p",[t("strong",[v._v("JVM 运行时数据区")]),v._v("是 JVM 规范定义的内存划分，不同 JDK 版本（如 JDK 8 及以上）的划分略有调整（核心变化是移除永久代、引入元空间），"),t("strong",[v._v("主流 JDK 8+ 标准划分包含 5 大核心区域")]),v._v("，以下结合功能、存储内容和核心特点详细说明：")]),v._v(" "),t("h3",{attrs:{id:"一、jvm-运行时数据区-jdk-8-核心划分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、jvm-运行时数据区-jdk-8-核心划分"}},[v._v("#")]),v._v(" 一、JVM 运行时数据区（JDK 8+ 核心划分）")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("区域名称")]),v._v(" "),t("th",[v._v("线程私有/共享")]),v._v(" "),t("th",[v._v("核心功能")]),v._v(" "),t("th",[v._v("存储内容")]),v._v(" "),t("th",[v._v("关键特点")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[t("strong",[v._v("程序计数器（PC Register）")])]),v._v(" "),t("td",[v._v("线程私有")]),v._v(" "),t("td",[v._v("记录当前线程执行的字节码指令地址（行号），是 JVM 中唯一不会 OOM 的区域")]),v._v(" "),t("td",[v._v("1. 执行 Java 方法：存储字节码指令的偏移量；"),t("br"),v._v("2. 执行 Native 方法：值为 undefined")]),v._v(" "),t("td",[v._v("1. 线程切换后能恢复到正确执行位置；"),t("br"),v._v("2. 无 OOM/StackOverflowError 异常")])]),v._v(" "),t("tr",[t("td",[t("strong",[v._v("Java 虚拟机栈（JVM Stack）")])]),v._v(" "),t("td",[v._v("线程私有")]),v._v(" "),t("td",[v._v("支撑 Java 方法的调用和执行，每个方法对应一个「栈帧」")]),v._v(" "),t("td",[v._v("栈帧（包含局部变量表、操作数栈、动态链接、方法返回地址等）")]),v._v(" "),t("td",[v._v("1. 局部变量表存储基本类型、对象引用、returnAddress 类型；"),t("br"),v._v("2. 栈深度溢出抛 StackOverflowError；"),t("br"),v._v("3. 栈扩展失败抛 OutOfMemoryError")])]),v._v(" "),t("tr",[t("td",[t("strong",[v._v("本地方法栈（Native Method Stack）")])]),v._v(" "),t("td",[v._v("线程私有")]),v._v(" "),t("td",[v._v("支撑 Native 方法（如 C/C++ 实现的方法）的调用和执行")]),v._v(" "),t("td",[v._v("本地方法执行的相关数据（与虚拟机栈逻辑类似，但针对 Native 方法）")]),v._v(" "),t("td",[v._v("1. HotSpot 虚拟机将其与虚拟机栈合并实现；"),t("br"),v._v("2. 同样会抛 StackOverflowError/OOM")])]),v._v(" "),t("tr",[t("td",[t("strong",[v._v("Java 堆（Heap）")])]),v._v(" "),t("td",[v._v("线程共享")]),v._v(" "),t("td",[v._v("JVM 最大的内存区域，唯一目的是存储对象实例和数组，是 GC（垃圾回收）的核心区域")]),v._v(" "),t("td",[v._v("所有通过 "),t("code",[v._v("new")]),v._v(" 创建的对象实例、数组（对象的元数据存元空间，实例存堆）")]),v._v(" "),t("td",[v._v("1. 可通过 "),t("code",[v._v("-Xms")]),v._v("（初始堆）、"),t("code",[v._v("-Xmx")]),v._v("（最大堆）配置大小；"),t("br"),v._v("2. 堆内存不足抛 OutOfMemoryError；"),t("br"),v._v("3. 细分：新生代（Eden + Survivor 0/1）、老年代")])]),v._v(" "),t("tr",[t("td",[t("strong",[v._v("方法区（Method Area）")])]),v._v(" "),t("td",[v._v("线程共享")]),v._v(" "),t("td",[v._v("存储类的元数据、常量、静态变量、即时编译器编译后的代码等")]),v._v(" "),t("td",[v._v("1. 类的结构信息（版本、字段、方法、接口）；"),t("br"),v._v("2. 运行时常量池；"),t("br"),v._v("3. 静态变量、JIT 编译后的代码")]),v._v(" "),t("td",[v._v("1. JDK 8 前用「永久代」实现，JDK 8+ 用「元空间（Metaspace）」替代（元空间直接使用本地内存）；"),t("br"),v._v("2. 内存不足抛 OutOfMemoryError（元空间溢出为 Metaspace OOM）")])])])]),v._v(" "),t("h3",{attrs:{id:"二、关键补充-易混淆概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、关键补充-易混淆概念"}},[v._v("#")]),v._v(" 二、关键补充（易混淆概念）")]),v._v(" "),t("h4",{attrs:{id:"_1-运行时常量池-runtime-constant-pool"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-运行时常量池-runtime-constant-pool"}},[v._v("#")]),v._v(" 1. 运行时常量池（Runtime Constant Pool）")]),v._v(" "),t("p",[v._v("属于"),t("strong",[v._v("方法区的一部分")]),v._v("，存储编译期生成的字面量（如字符串常量）、符号引用，以及运行时动态生成的常量（如 "),t("code",[v._v("String.intern()")]),v._v(" 生成的常量）。")]),v._v(" "),t("h4",{attrs:{id:"_2-元空间-metaspace-vs-永久代-permgen"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-元空间-metaspace-vs-永久代-permgen"}},[v._v("#")]),v._v(" 2. 元空间（Metaspace）vs 永久代（PermGen）")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("永久代（JDK 7 及以前）")]),v._v("：是方法区的实现方式，属于 JVM 堆的一部分，大小受 "),t("code",[v._v("-XX:PermSize")]),v._v("/"),t("code",[v._v("-XX:MaxPermSize")]),v._v(" 限制，容易触发 OOM；")]),v._v(" "),t("li",[t("strong",[v._v("元空间（JDK 8+）")]),v._v("：替代永久代实现方法区，直接使用操作系统的本地内存，默认无上限（可通过 "),t("code",[v._v("-XX:MetaspaceSize")]),v._v("/"),t("code",[v._v("-XX:MaxMetaspaceSize")]),v._v(" 限制），大幅减少 OOM 概率。")])]),v._v(" "),t("h4",{attrs:{id:"_3-直接内存-direct-memory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-直接内存-direct-memory"}},[v._v("#")]),v._v(" 3. 直接内存（Direct Memory）")]),v._v(" "),t("p",[t("strong",[v._v("不属于 JVM 规范定义的运行时数据区")]),v._v("，但常被关联提及：")]),v._v(" "),t("ul",[t("li",[v._v("是堆外内存（操作系统内存），通过 "),t("code",[v._v("ByteBuffer.allocateDirect()")]),v._v(" 分配；")]),v._v(" "),t("li",[v._v("不受 JVM 堆大小限制，但受物理内存总大小限制，也会触发 OOM；")]),v._v(" "),t("li",[v._v("NIO 框架常用直接内存提升 IO 性能（减少堆内存与堆外内存的拷贝）。")])]),v._v(" "),t("h3",{attrs:{id:"三、核心记忆要点-jdk-8"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、核心记忆要点-jdk-8"}},[v._v("#")]),v._v(" 三、核心记忆要点（JDK 8+）")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("线程私有 3 区")]),v._v("：程序计数器、虚拟机栈、本地方法栈；")]),v._v(" "),t("li",[t("strong",[v._v("线程共享 2 区")]),v._v("：Java 堆、方法区（元空间实现）；")]),v._v(" "),t("li",[t("strong",[v._v("OOM 例外")]),v._v("：仅程序计数器不会抛出 OutOfMemoryError；")]),v._v(" "),t("li",[t("strong",[v._v("GC 核心区")]),v._v("：Java 堆是垃圾回收的主要区域（方法区/元空间也有 GC，但频率极低）。")])]),v._v(" "),t("h2",{attrs:{id:"类加载的方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载的方式"}},[v._v("#")]),v._v(" 类加载的方式")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("命令行启动应用时候由JVM初始化加载")])]),v._v(" "),t("li",[t("p",[v._v("通过Class.forName（）方法动态加载")])]),v._v(" "),t("li",[t("p",[v._v("通过ClassLoader.loadClass（）方法动态加载")])])]),v._v(" "),t("h2",{attrs:{id:"java-的类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-的类加载器"}},[v._v("#")]),v._v(" JAVA 的类加载器：")]),v._v(" "),t("p",[v._v("AppClassLoader -> ExtClassLoader -> BootStrap ClassLoad"),t("br"),v._v("\n继承 AppClassLoader ,ExtClassLoader->URLClassLoader->SecureClassLoad->ClassLoader")]),v._v(" "),t("h2",{attrs:{id:"类加载过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载过程"}},[v._v("#")]),v._v(" 类加载过程")]),v._v(" "),t("p",[v._v("加载-》连接-》初始化"),t("br"),v._v("\n加载：将JAVA直接秒数据加载到JVM内存当中，并映射成JVM认可的数据结构"),t("br"),v._v("\n连接："),t("br"),v._v("\n1验证，"),t("br"),v._v("\n2准备，创建类或接口的静态变量，并赋初始值，半初始状态，"),t("br"),v._v("\n3.解析，符号转直接引用，栈初始化指针-映射堆引用地址，"),t("br"),v._v("\n初始化")]),v._v(" "),t("h2",{attrs:{id:"创建到清除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建到清除"}},[v._v("#")]),v._v(" 创建到清除")]),v._v(" "),t("ol",[t("li",[v._v("创建一个对象，JVM方法区找对象类型，然后创建对象")]),v._v(" "),t("li",[v._v("JVM 实例化对象，堆创建对象-半初始化")]),v._v(" "),t("li",[v._v("对象手写分配堆内存新生代Eden，经过异常MinorGc,存活转S1，每次存活S1.S2来回拷贝，移动一次，年龄+1,15之后老年区，因为 4字节")]),v._v(" "),t("li",[v._v("方法执行结束，栈指针先移除")]),v._v(" "),t("li",[v._v("堆中对象，经过Full GC ，标记垃圾，被GC清理")])]),v._v(" "),t("p",[v._v("不一定堆中，为了优化可能放栈中，生命周期简单，不用GC")]),v._v(" "),t("h2",{attrs:{id:"垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[v._v("#")]),v._v(" 垃圾回收")]),v._v(" "),t("h3",{attrs:{id:"确定是否垃圾"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#确定是否垃圾"}},[v._v("#")]),v._v(" 确定是否垃圾")]),v._v(" "),t("ol",[t("li",[v._v("引用计数，引用个数为0-》垃圾")]),v._v(" "),t("li",[v._v("根可达算法，GC Root找引用，找不到-》垃圾")])]),v._v(" "),t("p",[v._v("GC Root ：")]),v._v(" "),t("ul",[t("li",[v._v("Stack->JVM Stack ,Native Stack,class 类,")]),v._v(" "),t("li",[v._v("run-time constant pool 常量池")]),v._v(" "),t("li",[v._v("static reference 静态变量")])]),v._v(" "),t("h3",{attrs:{id:"jvm-垃圾回收算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm-垃圾回收算法"}},[v._v("#")]),v._v(" JVM 垃圾回收算法")]),v._v(" "),t("p",[v._v("MarkSweep 标记清除算法-》内存碎片\nCopying 拷贝算法-> 内存浪费，一半内存，效率和存活个数相关\nMarkCompack 标记压缩算法-》标记后，将存活往一端移")])])}),[],!1,null,null,null);t.default=r.exports}}]);