---
title: android 四大组件基础知识点
date: 2025-12-02
categories:
  - android
tags:
  - android
---

# Android 四大组件部分基础知识

## 一、 Activity

### 1. Activity 生命周期  
**onCreate** -> onContentChanged -> **onStart** -> onPostCreate -> **onResume** -> onPostResume -> **onPause** -> **onStop** -> **onDestroy**

### 2. Activity 启动模式
 * standard（默认）：每次启动新实例；
 * singleTop: 栈顶复用（如微信通知打开聊天窗口）（已有实例会调用 onNewIntent）
 * singleTask: 栈内复用（如应用home页）（已有实例会调用 onNewIntent）
 * singleInstance：单独栈中唯一实例（如电话拨号）


### 3.Fragment 生命周期
1. onAttach   
    - Fragment与Activity绑定时调用，可获取Activity引用，仅调用一次
2. onCreate
    - Fragment创建时调用，初始化数据（如viewModel、数据加载），与Activity的onCreate对应，仅调用一次。
3. onCreateView
    - 创建Fragment的视图，返回View对象（可为null），用于加载xml布局（如inflater.inflate(R.layout.fragment_main, container, false)）
4. onViewCreated   
    - 视图创建完成后调用，可初始化View控件，避免在onCreateView中直接操作View。
5. onActivityCreated
    - 宿主Activity的onCreate执行完毕后调用（已过时，推荐使用onViewCreated）
6. onStart
    - Fragment 可见时调用，与Activity的onStart同步
7. onResume
    - Fragment 可交互时调用，与Activity的onResume同步，此时Fragment处于活跃状态
8. onPause
    - Fragment失去焦点（activity暂停或Fragment被替换）时调用，与activity的onPause同步。
9. onStop
    - Fragment 不可见时调用，与activity的onStop同步
10. onDestroyView
    - Fragment 的视图被销毁时调用，需要释放view相关的资源（如解绑listener），此时getView()返回null
11. onDetach
    - Fragment与activity解绑时调用，仅调用一次，getActivity()返回null   

Fragment 的生命周期完全依赖于 Activity 的生命周期，Activity 的生命周期变化会直接触发 Fragment 的对应阶段，具体映射关系如下：

Fragment的生命周期完全依赖于Activity的生命周期，**Activity的生命周期变化会直接触发Fragment的对应阶段**，具体映射关系如下：

| Activity生命周期 | Fragment对应生命周期 |
|------------------|----------------------|
| onCreate()       | onAttach() → onCreate() → onCreateView() → onViewCreated() |
| onStart()        | onStart()            |
| onResume()       | onResume()           |
| onPause()        | onPause()            |
| onStop()         | onStop()             |
| onDestroy()      | onDestroyView() → onDestroy() → onDetach() |

关键场景下的生命周期变化
1. Fragment 被添加到 Activity   
onAttach() → onCreate() → onCreateView() → onViewCreated() → onStart() → onResume()

2. Fragment 被替换（replace）   
旧Fragment：onPause() → onStop() → onDestroyView() → onDestroy() → onDetach()   
新Fragment：onAttach() → onCreate() → onCreateView() → onViewCreated() → onStart() → onResume()

3. Fragment 被隐藏（hide）/ 显示（show）    
  * 隐藏：仅触发onHiddenChanged(true)（无生命周期方法调用）；
  * 显示：仅触发onHiddenChanged(false)（无生命周期方法调用）；
（注：hide/show不销毁视图，仅控制可见性）

4. Fragment 被添加到回退栈（addToBackStack）    
  * 替换 Fragment 时加入回退栈：旧 Fragment 仅执行onPause() → onStop() → onDestroyView()（视图销毁，实例保留）；
  * 从回退栈恢复：旧 Fragment 执行onCreateView() → onViewCreated() → onStart() → onResume()（视图重建）。

Fragment.setRetaininstance(true)有什么作用??(注意:此方法已弃用，但
了解其原理仍有价值)   
当 Activity 因配置变化（如横竖屏切换、屏幕尺寸调整）销毁并重建时，默认情况下 Fragment 会随 Activity 一起销毁（执行onDestroy()→onDetach()），再重新创建新实例。

### 4. Fragment 与 Activity 通信的方式  
  * 通过接口回调（Fragment 定义接口，Activity 实现）；
  * 使用 ViewModel（共享数据，生命周期独立于 Fragment）；
  * 通过setArguments()/getArguments()传递数据；
  * 使用 LiveData/EventBus 实现跨组件通信。

### Intent 与 Intent Filter.
1. 显式Intent
    - 直接指定目标组件的类名（如 Activity、Service），系统直接匹配目标组件，无需 Intent Filter
2. 隐式Intent
    - 不指定具体组件，通过Action、Category、Data等属性描述意图，系统通过 Intent Filter 匹配最合适的组件
    ```java
    // 打开浏览器访问网址
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setData(Uri.parse("https://www.baidu.com"));
    startActivity(intent);
    ```
3. Intent 通过 **Binder** 传递，数据大小限制约 **1MB**；大数据可通过FileProvider、Binder或本地存储（文件 / 数据库）传递。


## 二、Service

### Service生命周期
1. 启动服务 onCreate -> onStartConmmand -> onDestroy;
  * startService(new Intent(this,Myservice.class)),服务独立运行，需手动停止（stopSelf()（自身）/stopService()（外部））
2. 绑定服务 onCreate -> onBind ->onUnbind -> onDestroy;
  * bindService(intent,serviceConnection,BIND_AUTO_CREATE),与组件绑定，组件销毁时服务解绑。
3. 即启动又绑定：需同时stopService()和unbindService才会销毁。

Foreground Service()前台服务
在 onStartCommand() 中调用 startForeground() 将服务提升为前台服务（需传入通知 ID 和 Notification 对象）在 Activity 中通过 startForegroundService() 启动（Android 8.0+ 必须用此方法，而非 startService()）  停止服务：调用 stopForeground(true) 可移除通知并降级为普通服务，或 stopSelf() 直接停止服务。
前台服务必须显示通知，且通知需包含小图标（setSmallIcon()），否则会抛出异常

## 三、BroadcastReceiver
作用：监听系统 / 应用发出的广播事件（如网络变化、开机完成），实现组件间通信。

### 基础使用：    
- 定义：继承BroadcastReceiver，重写onReceive(Context context, Intent intent)
- 注册方式：
    1. 静态注册：AndroidManifest.xml中注册，常驻系统（即使应用关闭）
    2. 动态注册：代码中注册（registerReceiver(receiver, intentFilter)）,需在onDestroy()中解绑（unregisterReceiver(receiver)）

### 发送广播    
  - 普通广播：sendBroadcast(intent),异步传递，可被多个接收器接收；
  - 有序广播：sendOrderedBroadcast(intent,null),可按优先级传递，可中断；
  - 本地广播：LocalBroadcastManager发送，仅自己应用内接收，更安全。

## 四、ContentProvider
ContentProvider 是 Android 四大组件之一，本质是跨进程数据交互的 “中间者” ，自身不存储数据，仅封装数据访问接口，真正数据源可为 SQLite 数据库、文件、XML 或网络数据。 底层是基于Android的**Binder**机制实现跨进程通信，通过Binder代理完成客户端（ContentResolver）与服务端（ContentProvider）的数据交互。  

### 基础使用
1. 定义：继承ContentProvider，重写onCreate()、query()、insert()、update()、delete()、getType();
2. 注册：AndroidManifest.xml中注册
3. 访问数据：通过ContentResolver调用方法，如
`getContentResolver().query(Uri.pare("content://com.example.myprovider/data"),null,null,null,null)`
getType返回当前Uri所代表数据的MIME类型

### ContentResolver 类  
* 作用：统一管理对不同ContentProvider的操作，避免客户端直接与多个ContentProvider交互复杂性。
* 核心方法 ：提供与ContentProvier对应的4个数据操作方法，通过Context.getContentResolver()获取实例：
```java
ContentResolver resolver = getContentResolver();
// 插入数据
resolver.insert(uri, values);
// 查询数据
Cursor cursor = resolver.query(uri, projection, selection, selectionArgs, sortOrder);
// 更新数据
resolver.update(uri, values, selection, selectionArgs);
// 删除数据
resolver.delete(uri, selection, selectionArgs);
```


#### （4）辅助工具类
##### ① ContentUris
- **作用**：简化URI的“追加ID”与“解析ID”操作。  
- **核心方法**：
  - `withAppendedId(Uri baseUri, long id)`：向基础URI追加ID，示例：  
    ```java
    Uri baseUri = Uri.parse("content://com.carson.provider/User");
    Uri newUri = ContentUris.withAppendedId(baseUri, 7); // 结果：content://com.carson.provider/User/7
    ```
  - `parseId(Uri uri)`：从URI中解析出ID，示例：  
    ```java
    long id = ContentUris.parseId(newUri); // 结果：7
    ```

##### ② UriMatcher
- **作用**：注册URI并根据URI匹配对应的数据表，解决“不同URI对应不同数据资源”的映射问题。  
- **使用步骤**：
  1. 初始化：`UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH);`（NO_MATCH表示初始不匹配任何URI）；  
  2. 注册URI：`matcher.addURI(Authority, Path, 匹配码);`，示例：  
     ```java
     matcher.addURI("com.carson.provider", "User", 1); // URI=content://com.carson.provider/User时，匹配码=1
     matcher.addURI("com.carson.provider", "Job", 2); // URI=content://com.carson.provider/Job时，匹配码=2
     ```
  3. 匹配URI：`int matchCode = matcher.match(uri);`，根据匹配码确定对应数据表。

##### ③ **ContentObserver**
- **定义**：内容观察者，监听URI对应ContentProvider的数据变化，并通知外界。  
- **使用步骤**：
  1. **注册观察者**：通过ContentResolver注册，指定监听的URI：  
     ```java
     getContentResolver().registerContentObserver(uri, true, new MyContentObserver(handler));
     ```
  2. **发送通知**：ContentProvider数据变化时（如insert/delete/update后），调用`notifyChange()`通知观察者：  
     ```java
     getContext().getContentResolver().notifyChange(uri, null);
     ```
  3. **处理变化**：自定义ContentObserver并重写`onChange()`，响应数据变化（如刷新UI）：  
     ```java
     class MyContentObserver extends ContentObserver {
         @Override
         public void onChange(boolean selfChange) {
             super.onChange(selfChange);
             // 数据变化后的操作（如重新查询数据）
         }
     }
     ```
  4. **解除观察者**：在组件销毁时解除，避免内存泄漏：  
     ```java
     @Override
     protected void onDestroy() {
         super.onDestroy();
         getContentResolver().unregisterContentObserver(observer);
     }
     ```


### ContentProvider 实例演示
#### （1）进程内通信
| 步骤 | 操作内容 | 关键代码示例 |
|------|----------|--------------|
| 1 | 创建DBHelper（初始化数据库） | 继承SQLiteOpenHelper，重写onCreate()创建表（如User表、Job表） |
| 2 | 自定义ContentProvider | 重写6个核心方法，通过UriMatcher匹配URI与数据表，操作SQLite |
| 3 | 注册ContentProvider | 在Manifest中注册：`<provider android:name=".MyProvider" android:authorities="com.carson.provider"/>` |
| 4 | 访问数据 | 通过ContentResolver根据URI插入、查询数据 |

#### （2）进程间通信
- **进程1（服务端）**：  
  1. 完成“进程内通信”的3个步骤（DBHelper、自定义ContentProvider、注册）；  
  2. 在Manifest中声明访问权限：  
     ```xml
     <permission android:name="com.carson.provider.PERMISSION" android:protectionLevel="normal"/>
     <provider 
         android:name=".MyProvider"
         android:authorities="com.carson.provider"
         android:permission="com.carson.provider.PERMISSION"
         android:exported="true"/> <!-- 允许其他进程访问 -->
     ```
- **进程2（客户端）**：  
  1. 在Manifest中声明权限：`<uses-permission android:name="com.carson.provider.PERMISSION"/>`；  
  2. 通过ContentResolver访问进程1的ContentProvider（代码与进程内通信一致，URI需匹配进程1的Authority）。


### ContentProvider 核心优点
1. **安全性**：仅通过封装的接口开放数据访问，避免直接开放数据库权限导致的安全风险；  
2. **访问高效性**：解耦底层数据存储方式（如从SQLite切换为MongoDB），上层访问代码无需修改，统一访问接口；  
3. **通用性**：支持多种数据源，且适配进程内、进程间两种通信场景。

