---
title: android 启动过程源代码分析
date: 2025-11-27
categories:
  - android
tags:
  - android
  - 源码分析
---

#  Android应用程序启动过程源代码分析

***
参考老罗分享的[启动过程源码分析](https://blog.csdn.net/luoshengyang/article/details/6689748)学习时发现新版有差异，但是核心逻辑没变,后续根据Android API 30分析(参考[掘金分享](https://juejin.cn/post/7502457440443039795))，查看其他版本可以在
[官网源码](https://android.googlesource.com/platform/frameworks/base/+refs) 查看
***
# 一、Launcher 阶段
## Step 1.Launcher.startActivitySafely
```java
public final class Launcher extends Activity
		implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks, AllAppsView.Watcher {
	......
	public void onClick(View v) {
		Object tag = v.getTag();
		if (tag instanceof ShortcutInfo) {
			// Open shortcut
			final Intent intent = ((ShortcutInfo) tag).intent;
			int[] pos = new int[2];
			v.getLocationOnScreen(pos);
			intent.setSourceBounds(new Rect(pos[0], pos[1],
				pos[0] + v.getWidth(), pos[1] + v.getHeight()));
			startActivitySafely(intent, tag);
		} else if (tag instanceof FolderInfo) {
			......
		} else if (v == mHandleView) {
			......
		}
	}
 
	void startActivitySafely(Intent intent, Object tag) {
		intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
		try {
			startActivity(intent);
		} catch (ActivityNotFoundException e) {
			......
		} catch (SecurityException e) {
			......
		}
	}
	......
}
```

```xml
<activity android:name=".MainActivity"  
      android:label="@string/app_name">  
       <intent-filter>  
        <action android:name="android.intent.action.MAIN" />  
        <category android:name="android.intent.category.LAUNCHER" />  
    </intent-filter>  
</activity>  
```
### 1.1分析
intent包含信息：  
1.action = "android.intent.action.Main"
2.category="android.intent.category.LAUNCHER"
3.cmp="shy.luo.activity/.MainActivity"  
4.Intent.FLAG_ACTIVITY_NEW_TASK  
**FLAG_ACTIVITY_NEW_TASK**表示要在一个新的**task**中启动这个activity，这里**不是进程**[task相关资料](http://developer.android.com/guide/topics/manifest/activity-element.html)

## Step 2. Activity.startActivity
Launcher : activity ,实际调用的还是activity中的startActivity
``` java 
@Override
public void startActivity(Intent intent, @Nullable Bundle options) {
    if (options != null) {
        startActivityForResult(intent, -1, options);
    } else {
        startActivityForResult(intent, -1);
    }
}
```
### 2.1 相关分析
startActivity 实际都是调用的startActivityForResult，第二个参数传入-1表示不需要这个Actvity结束后的返回结果。

##  Step 3. Activity.startActivityForResult

```java
public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) {
    if (mParent == null) {
        options = transferSpringboardActivityOptions(options);
        Instrumentation.ActivityResult ar =
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, this,
                intent, requestCode, options);
        if (ar != null) {
            //ActivityThread里面调用
            mMainThread.sendActivityResult(
                mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                ar.getResultData());
        }
        if (requestCode >= 0) {
            //需要结果时可以在onCreate或onResume中设置，作用：保存隐藏，避免闪烁
            mStartedActivity = true;
        }
        //取消待处理的输入，如果要运行活动转换
        cancelInputsAndStartExitTransition(options);
    } else {
        if (options != null) {
            mParent.startActivityFromChild(this, intent, requestCode, options);
        } else {
            mParent.startActivityFromChild(this, intent, requestCode);
        }
    }
}
```
### 3.1 相关分析
1. 启动流程中主要关注**mInstrumentation.execStartActivity**，Instrumentation、ActivityThread等都是在activity.**attach**中接收的，具体初始化后续再分析。  
2. Instrumentation：用来监控应用程序和系统的交互，mMainThread 就是ActivityThread实例，mToken是Binder对象的远程接口。 
3. 这里通过**mMainThread.getApplicationThread**获取ApplicationThread，是一个Binder对象，后面我们会看到，ActivityManagerService会使用它来和ActivityThread来进行进程间通信。这里我们需注意的是，这里的mMainThread代表的是Launcher应用程序运行的进程。

##  Step 4. **Instrumentation.execStartActivity**
```java 
public ActivityResult execStartActivity(
	Context who, IBinder contextThread, IBinder token, Activity target,
	Intent intent, int requestCode) {
		IApplicationThread whoThread = (IApplicationThread) contextThread;
		if (mActivityMonitors != null) {
            //在真正启动目标 Activity 前，通过注册的 ActivityMonitor（Activity 监控器）拦截启动请求，  
            //根据监控器规则返回预设结果或放行，实现对 Activity 启动的监听、拦截和模拟响应。
			......
		}
		try {
	        intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(who);
            int result = ActivityManager.getService()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != null ? target.mEmbeddedID : null,
                        requestCode, 0, null, options);
			......
		} catch (RemoteException e) {
		}
		return null;
	}
```
```java
//ActivityManager class
public static IActivityTaskManager getService() {
    return IActivityTaskManagerSingleton.get();
}

@UnsupportedAppUsage(trackingBug = 129726065)
private static final Singleton<IActivityTaskManager> IActivityTaskManagerSingleton =
        new Singleton<IActivityTaskManager>() {
            @Override
            protected IActivityTaskManager create() {
                final IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);
                return IActivityTaskManager.Stub.asInterface(b);
            }
        };
```
### 4.1 相关分析
**ActivityTaskManager.getService()**返回**ActivityTaskManagerService**的远程接口。  
基于 Binder 机制,**本质是通过 Binder 代理转发给 ATMS 真身**；

# 二、AMS 处理阶段

## Step 5. ActivityTaskManagerService.startActivity

```java
//System service for managing activities and their containers (task, stacks, displays,... )
//用于管理活动及其容器(任务、堆栈、显示等)的系统服务。
public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
    ......
    @Override
    public final int startActivity(IApplicationThread caller, String callingPackage,
            String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,
            String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo,
            Bundle bOptions) {
        return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,
                resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions,
                UserHandle.getCallingUserId());
    }
    ......
    @Override
    public int startActivityAsUser(IApplicationThread caller, String callingPackage,
            String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,
            String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo,
            Bundle bOptions, int userId) {
        return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,
                resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,
                true /*validateIncomingUser*/);
    }

    private int startActivityAsUser(IApplicationThread caller, String callingPackage,
            @Nullable String callingFeatureId, Intent intent, String resolvedType,
            IBinder resultTo, String resultWho, int requestCode, int startFlags,
            ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) {
        //权限与包名校验
        assertPackageMatchesCallingUid(callingPackage);
        // 判断调用者进程是否被隔离
        enforceNotIsolatedCaller("startActivityAsUser");
        //用户身份校验与确认(多用户场景核心）
        userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,
                Binder.getCallingPid(), Binder.getCallingUid(), "startActivityAsUser");

        //切换到用户应用堆栈:
        return getActivityStartController().obtainStarter(intent, "startActivityAsUser")
            .setCaller(caller)                // 发起方的 IApplicationThread（Binder 代理，用于回调结果）
            .setCallingPackage(callingPackage)// 发起方包名（用于权限校验、日志）
            .setCallingFeatureId(callingFeatureId)// 发起方的 Feature ID（Android 9+ 新增，用于模块化App）
            .setResolvedType(resolvedType)    // Intent 的 MIME 类型（比如 "image/*"，从 intent.resolveTypeIfNeeded 得到）
            .setResultTo(resultTo)            // 接收返回结果的 Activity 的 Binder token（比如 startActivityForResult 时用到）
            .setResultWho(resultWho)          // 接收结果的 "who" 标识（配合 requestCode 使用）
            .setRequestCode(requestCode)      // 启动请求码（startActivityForResult 时的请求码，-1 表示不需要结果）
            .setStartFlags(startFlags)        // 启动标志（比如 FLAG_ACTIVITY_NEW_TASK、FLAG_ACTIVITY_CLEAR_TOP 等）
            .setProfilerInfo(profilerInfo)    // 性能分析相关信息（非必要，可为 null）
            .setActivityOptions(bOptions)     // 启动配置（比如动画、栈模式、分屏等，对应上层的 ActivityOptions）
            .setUserId(userId)                // 最终确认的目标用户 ID
            .execute();                       // 执行启动流程

    }
    ......
    private void enforceNotIsolatedCaller(String caller) {
        if (UserHandle.isIsolated(Binder.getCallingUid())) {
            throw new SecurityException("Isolated process not allowed to call " + caller);
        }
    }
    ......
}

```
### 5.1分析
1. 最终会调用startActivityAsUser ,**ActivityStartController**
2. ActivityTaskManagerService 用于管理活动及其容器(任务、堆栈、显示等)的系统服务。
3. startActivityAsUser 是 ATMS 中承接跨进程启动请求、初始化启动参数并转交核心控制器处理的关键方法—— 它不直接执行启动逻辑，而是做 “参数校验、用户身份确认、启动参数封装”，**最终把请求交给ActivityStartController**
4. **ActivityStarter** 是启动 Activity 的控制类，根据设置的参数来决定如何根据 Intent 和 Flags 来启动 Activity，并将 Activity 和 Task 以及 Stack 相关联。它在调用 ActivityStarter 的 execute 方法之前一直有效。
5. 调用者进程如果被隔离或者无权限会抛出 SecurityException 异常。最后调用 ActivityStartController 的 obtainStarter 方法获取一个 ActivityStarter 对象。


我们先看 ActivityStartController 的核心逻辑：
```java 
public class ActivityStartController {
    private final ActivityTaskManagerService mService;
    private final ActivityStackSupervisor mSupervisor;
    private final ActivityStarter mLastStarter;
    ActivityStarter obtainStarter(Intent intent, String reason) {
        return mFactory.obtain().setIntent(intent).setReason(reason);
    }
}
```
mFactory.obtain() 在ActivityStarter 中返回**ActivityStarter** 最终调用的ActivityStarter.execute()  

## Step 6. ActivityStarter.execute 
```java 
int execute() {
    ...
    res = executeRequest(mRequest);
    ...
}

```

```java 
private int executeRequest(Request request) {
    ...
    ActivityRecord sourceRecord = null;
    ActivityRecord resultRecord = null;
    if (resultTo != null) {
        sourceRecord = mRootWindowContainer.isInAnyStack(resultTo);
        if (sourceRecord != null) {
            if (requestCode >= 0 && !sourceRecord.finishing) {
                resultRecord = sourceRecord;
            }
        }
    }
    ...
    mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession,
        request.voiceInteractor, startFlags, true /* doResume */, checkedOptions, inTask,
        restrictedBgActivity, intentGrants);
    ...
    return mLastStartActivityResult;
}

```
### 6.1 分析
1. execute 里面调用 executeRequest 
2. executeRequest 执行 Activity 启动请求，这里首先执几项初步检查，并创建了 ActivityRecord：
3. ActivityRecord 用于维护一个 Activity 的相关信息，如任务栈、生命周期等。

## Step 7. ActivityStarter.startActivityUnchecked
```java
private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            int startFlags, boolean doResume, ActivityOptions options, Task inTask,
            boolean restrictedBgActivity, NeededUriGrants intentGrants) {
    int result = START_CANCELED;
    final ActivityStack startedActivityStack;
    try {
        mService.deferWindowLayout();
        Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, "startActivityInner");
        result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor,
                startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
        startedActivityStack = handleStartResult(r, result);
        mService.continueWindowLayout();
    }

    postStartActivityProcessing(r, result, startedActivityStack);

    return result;
}
```
### 7.1 分析
startActivityUnchecked 在完成大部分初步检查并确认调用方拥有执行此操作的必要权限时启动 Activity，还确保在启动不成功时删除正在启动的 Activity:

## Step 8. startActivityInner
```java 
int startActivityInner(final ActivityRecord r, ActivityRecord sourceRecord,
        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
        int startFlags, ActivityOptions options, Task inTask,
        TaskFragment inTaskFragment, BalVerdict balVerdict,
        NeededUriGrants intentGrants, int realCallingUid) {
    setInitialState(r, options, inTask, inTaskFragment, startFlags, sourceRecord,
            voiceSession, voiceInteractor, balVerdict.getCode(), realCallingUid);
    ...···....
    // Flag 为 FLAG_ACTIVITY_NEW_TASK，根据 computeTargetTask 计算需要返回 null，表示需要新的 Task
    final Task targetTask = reusedTask != null ? reusedTask : computeTargetTask();
    final boolean newTask = targetTask == null;// true
    mTargetTask = targetTask;
    computeLaunchParams(r, sourceRecord, targetTask);
    ...
    // Task 为 null，创建新的 ActivityRecord 为 null
    final ActivityRecord targetTaskTop = newTask
            ? null : targetTask.getTopNonFinishingActivity();
    if (targetTaskTop != null) {
        ...
    } else {
        mAddingToTask = true;
    }
    ...
    if (mTargetRootTask == null) {
        // 创建 Task
        mTargetRootTask = getOrCreateRootTask(mStartActivity, mLaunchFlags, targetTask,
                mOptions);
    }
    if (newTask) {
        final Task taskToAffiliate = (mLaunchTaskBehind && mSourceRecord != null)
                ? mSourceRecord.getTask() : null;
        // 将 ActivityRecord 与 Task 关联
        setNewTask(taskToAffiliate);
    } 
    ...
    if (!mAvoidMoveToFront && mDoResume) {
        logOnlyCreatorAllowsBAL(balVerdict, realCallingUid, newTask);
        // 移动到栈顶
        mTargetRootTask.getRootTask().moveToFront("reuseOrNewTask", targetTask);
        ...
    }

    ...
    if (mDoResume) {
        final com.android.server.wm.ActivityRecord topTaskActivity = startedTask.topRunningActivityLocked();
        if (!mTargetRootTask.isTopActivityFocusable())
            ...
        } else {
            ...
            // Activity resume
            mRootWindowContainer.resumeFocusedTasksTopActivities(
                    mTargetRootTask, mStartActivity, mOptions, mTransientLaunch);
        }
    mRootWindowContainer.updateUserRootTask(mStartActivity.mUserId, mTargetRootTask);

    // 当活动开始时，立即更新最近任务列表
    mSupervisor.mRecentTasks.add(startedTask);
    mSupervisor.handleNonResizableTaskIfNeeded(startedTask,
            mPreferredWindowingMode, mPreferredTaskDisplayArea, mTargetRootTask);

    // 如果 Activity 正在启动进入画中画模式，则立即将 mStartActivity 移动到固定模式。
    // 请注意，此时 mStartActivity 和源 Activity 应处于同一任务中。
    if (mOptions != null && mOptions.isLaunchIntoPip()
            && sourceRecord != null && sourceRecord.getTask() == mStartActivity.getTask()
            && balVerdict.allows()) {
        mRootWindowContainer.moveActivityToPinnedRootTask(mStartActivity,
                sourceRecord, "launch-into-pip");
    }

    mSupervisor.getBackgroundActivityLaunchController()
            .onNewActivityLaunched(mStartActivity);

    return START_SUCCESS;
}

```
### 8.1 分析
1. startActivityInner 启动 Activity 并确定该 Activity 是否应添加到已经存在的 task 的顶部或向现有 activity 传递新 Intent
2. startActivityInner 首先创建了 Task，接着将 ActivityRecord 挂载到创建的 Task 下，并移动 Task 到栈顶，最后调用 RootWindowContainer resumeFocusedTasksTopActivities 方法显示顶部的 Activity
3. RootWindowContainer 是窗口管理树的根节点，负责管理整个系统中所有窗口的层级关系和布局，以及处理窗口的生命周期和多屏幕支持。
## Step 9. RootWindowContainer.resumeFocusedStacksTopActivities
```java
boolean resumeFocusedTasksTopActivities(
        Task targetRootTask, ActivityRecord target, ActivityOptions targetOptions,
        boolean deferPause) {
    if (!mTaskSupervisor.readyToResume()) {
        return false;
    }

    boolean result = false;
    if (targetRootTask != null && (targetRootTask.isTopRootTaskInDisplayArea()
            || getTopDisplayFocusedRootTask() == targetRootTask)) {
        // targetRootTask 就是刚创建的目标 Task
        result = targetRootTask.resumeTopActivityUncheckedLocked(target, targetOptions,
                deferPause);
    }

    for (int displayNdx = getChildCount() - 1; displayNdx >= 0; --displayNdx) {
        final DisplayContent display = getChildAt(displayNdx);
        final boolean curResult = result;
        boolean[] resumedOnDisplay = new boolean[1];
        display.forAllRootTasks(rootTask -> {
            final ActivityRecord topRunningActivity = rootTask.topRunningActivity();
            if (!rootTask.isFocusableAndVisible() || topRunningActivity == null) {
                return;
            }
            if (rootTask == targetRootTask) {
                resumedOnDisplay[0] |= curResult;
                return;
            }
            if (topRunningActivity.isState(RESUMED)
                    && topRunningActivity == rootTask.getDisplayArea().topRunningActivity()) {
                rootTask.executeAppTransition(targetOptions);
            } else {
                resumedOnDisplay[0] |= topRunningActivity.makeActiveIfNeeded(target);
            }
        });
        result |= resumedOnDisplay[0];
        if (!resumedOnDisplay[0]) {
            final com.android.server.wm.Task focusedRoot = display.getFocusedRootTask();
            if (focusedRoot != null) {
                result |= focusedRoot.resumeTopActivityUncheckedLocked(target, targetOptions);
            } else if (targetRootTask == null) {
                result |= resumeHomeActivity(null /* prev */, "no-focusable-task",
                        display.getDefaultTaskDisplayArea());
            }
        }
    }

    return result;
}

```

RootWindowContainer 是窗口管理树的根节点，负责管理整个系统中所有窗口的层级关系和布局，以及处理窗口的生命周期和多屏幕支持。
看一下 RootWindowContainer 的 resumeFocusedTasksTopActivities，是实现 Activity 显示和切换的关键方法：

## Step 10.ActivityStack.resumeFocusedTasksTopActivities
```java
@GuardedBy("mService")
    boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {
        if (mInResumeTopActivity) {
           // 别去尝试递归操作了。
            return false;
        }

        boolean result = false;
        try {
            // 防止递归。
            mInResumeTopActivity = true;
            result = resumeTopActivityInnerLocked(prev, options);

            // 当重新启动最顶层的活动时，可能需要暂停最顶层的活动（例如返回锁屏界面。我们在 {@link #resumeTopActivityUncheckedLocked}   
            // 中抑制了常规的暂停逻辑，因为最顶层的活动会在结束时重新启动。我们在这里再次调用   
            // {@link ActivityStackSupervisor#checkReadyForSleepLocked} 以确保任何必要的暂停逻辑得以执行。  
            // 如果该活动无论是否处于锁屏状态都会显示出来，那么就不会调用   
            // {@link ActivityStackSupervisor#checkReadyForSleepLocked} 。
            final ActivityRecord next = topRunningActivity(true /* focusableOnly */);
            if (next == null || !next.canTurnScreenOn()) {
                checkReadyForSleep();
            }
        } finally {
            mInResumeTopActivity = false;
        }

        return result;
    }

```

## Step 11. ActivityStack.resumeTopActivityInnerLocked
```java
@GuardedBy("mService")
    private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {
        if (!mAtmService.isBooting() && !mAtmService.isBooted()) {
            // Not ready yet!
            return false;
        }

        // Find the next top-most activity to resume in this stack that is not finishing and is
        // focusable. If it is not focusable, we will fall into the case below to resume the
        // top activity in the next focusable task.
        ActivityRecord next = topRunningActivity(true /* focusableOnly */);

        final boolean hasRunningActivity = next != null;

        // TODO: Maybe this entire condition can get removed?
        if (hasRunningActivity && !isAttached()) {
            return false;
        }

        mRootWindowContainer.cancelInitializingActivities();

        // Remember how we'll process this pause/resume situation, and ensure
        // that the state is reset however we wind up proceeding.
        boolean userLeaving = mStackSupervisor.mUserLeaving;
        mStackSupervisor.mUserLeaving = false;

        if (!hasRunningActivity) {
            // There are no activities left in the stack, let's look somewhere else.
            return resumeNextFocusableActivityWhenStackIsEmpty(prev, options);
        }

        next.delayedResume = false;
        final TaskDisplayArea taskDisplayArea = getDisplayArea();

        // If the top activity is the resumed one, nothing to do.
        if (mResumedActivity == next && next.isState(RESUMED)
                && taskDisplayArea.allResumedActivitiesComplete()) {
            // Make sure we have executed any pending transitions, since there
            // should be nothing left to do at this point.
            executeAppTransition(options);
            if (DEBUG_STATES) Slog.d(TAG_STATES,
                    "resumeTopActivityLocked: Top activity resumed " + next);
            return false;
        }

        if (!next.canResumeByCompat()) {
            return false;
        }

        // If we are currently pausing an activity, then don't do anything until that is done.
        final boolean allPausedComplete = mRootWindowContainer.allPausedActivitiesComplete();
        if (!allPausedComplete) {
            if (DEBUG_SWITCH || DEBUG_PAUSE || DEBUG_STATES) {
                Slog.v(TAG_PAUSE, "resumeTopActivityLocked: Skip resume: some activity pausing.");
            }
            return false;
        }

        // If we are sleeping, and there is no resumed activity, and the top activity is paused,
        // well that is the state we want.
        if (shouldSleepOrShutDownActivities()
                && mLastPausedActivity == next
                && mRootWindowContainer.allPausedActivitiesComplete()) {
            // If the current top activity may be able to occlude keyguard but the occluded state
            // has not been set, update visibility and check again if we should continue to resume.
            boolean nothingToResume = true;
            if (!mAtmService.mShuttingDown) {
                final boolean canShowWhenLocked = !mTopActivityOccludesKeyguard
                        && next.canShowWhenLocked();
                final boolean mayDismissKeyguard = mTopDismissingKeyguardActivity != next
                        && next.containsDismissKeyguardWindow();

                if (canShowWhenLocked || mayDismissKeyguard) {
                    ensureActivitiesVisible(null /* starting */, 0 /* configChanges */,
                            !PRESERVE_WINDOWS);
                    nothingToResume = shouldSleepActivities();
                } else if (next.currentLaunchCanTurnScreenOn() && next.canTurnScreenOn()) {
                    nothingToResume = false;
                }
            }
            if (nothingToResume) {
                // Make sure we have executed any pending transitions, since there
                // should be nothing left to do at this point.
                executeAppTransition(options);
                if (DEBUG_STATES) Slog.d(TAG_STATES,
                        "resumeTopActivityLocked: Going to sleep and all paused");
                return false;
            }
        }

        // Make sure that the user who owns this activity is started.  If not,
        // we will just leave it as is because someone should be bringing
        // another user's activities to the top of the stack.
        if (!mAtmService.mAmInternal.hasStartedUserState(next.mUserId)) {
            Slog.w(TAG, "Skipping resume of top activity " + next
                    + ": user " + next.mUserId + " is stopped");
            return false;
        }

        // The activity may be waiting for stop, but that is no longer
        // appropriate for it.
        mStackSupervisor.mStoppingActivities.remove(next);
        next.setSleeping(false);

        if (DEBUG_SWITCH) Slog.v(TAG_SWITCH, "Resuming " + next);

        // If we are currently pausing an activity, then don't do anything until that is done.
        if (!mRootWindowContainer.allPausedActivitiesComplete()) {
            if (DEBUG_SWITCH || DEBUG_PAUSE || DEBUG_STATES) Slog.v(TAG_PAUSE,
                    "resumeTopActivityLocked: Skip resume: some activity pausing.");

            return false;
        }

        mStackSupervisor.setLaunchSource(next.info.applicationInfo.uid);

        ActivityRecord lastResumed = null;
        final ActivityStack lastFocusedStack = taskDisplayArea.getLastFocusedStack();
        if (lastFocusedStack != null && lastFocusedStack != this) {
            // So, why aren't we using prev here??? See the param comment on the method. prev doesn't
            // represent the last resumed activity. However, the last focus stack does if it isn't null.
            lastResumed = lastFocusedStack.mResumedActivity;
            if (userLeaving && inMultiWindowMode() && lastFocusedStack.shouldBeVisible(next)) {
                // The user isn't leaving if this stack is the multi-window mode and the last
                // focused stack should still be visible.
                if(DEBUG_USER_LEAVING) Slog.i(TAG_USER_LEAVING, "Overriding userLeaving to false"
                        + " next=" + next + " lastResumed=" + lastResumed);
                userLeaving = false;
            }
        }

        boolean pausing = taskDisplayArea.pauseBackStacks(userLeaving, next);
        if (mResumedActivity != null) {
            if (DEBUG_STATES) Slog.d(TAG_STATES,
                    "resumeTopActivityLocked: Pausing " + mResumedActivity);
            pausing |= startPausingLocked(userLeaving, false /* uiSleeping */, next);
        }
        if (pausing) {
            if (DEBUG_SWITCH || DEBUG_STATES) Slog.v(TAG_STATES,
                    "resumeTopActivityLocked: Skip resume: need to start pausing");
            // At this point we want to put the upcoming activity's process
            // at the top of the LRU list, since we know we will be needing it
            // very soon and it would be a waste to let it get killed if it
            // happens to be sitting towards the end.
            if (next.attachedToProcess()) {
                next.app.updateProcessInfo(false /* updateServiceConnectionActivities */,
                        true /* activityChange */, false /* updateOomAdj */,
                        false /* addPendingTopUid */);
            } else if (!next.isProcessRunning()) {
                // Since the start-process is asynchronous, if we already know the process of next
                // activity isn't running, we can start the process earlier to save the time to wait
                // for the current activity to be paused.
                final boolean isTop = this == taskDisplayArea.getFocusedStack();
                mAtmService.startProcessAsync(next, false /* knownToBeDead */, isTop,
                        isTop ? "pre-top-activity" : "pre-activity");
            }
            if (lastResumed != null) {
                lastResumed.setWillCloseOrEnterPip(true);
            }
            return true;
        } else if (mResumedActivity == next && next.isState(RESUMED)
                && taskDisplayArea.allResumedActivitiesComplete()) {
            // It is possible for the activity to be resumed when we paused back stacks above if the
            // next activity doesn't have to wait for pause to complete.
            // So, nothing else to-do except:
            // Make sure we have executed any pending transitions, since there
            // should be nothing left to do at this point.
            executeAppTransition(options);
            if (DEBUG_STATES) Slog.d(TAG_STATES,
                    "resumeTopActivityLocked: Top activity resumed (dontWaitForPause) " + next);
            return true;
        }

        // If the most recent activity was noHistory but was only stopped rather
        // than stopped+finished because the device went to sleep, we need to make
        // sure to finish it as we're making a new activity topmost.
        if (shouldSleepActivities() && mLastNoHistoryActivity != null &&
                !mLastNoHistoryActivity.finishing) {
            if (DEBUG_STATES) Slog.d(TAG_STATES,
                    "no-history finish of " + mLastNoHistoryActivity + " on new resume");
            mLastNoHistoryActivity.finishIfPossible("resume-no-history", false /* oomAdj */);
            mLastNoHistoryActivity = null;
        }

        if (prev != null && prev != next && next.nowVisible) {

            // The next activity is already visible, so hide the previous
            // activity's windows right now so we can show the new one ASAP.
            // We only do this if the previous is finishing, which should mean
            // it is on top of the one being resumed so hiding it quickly
            // is good.  Otherwise, we want to do the normal route of allowing
            // the resumed activity to be shown so we can decide if the
            // previous should actually be hidden depending on whether the
            // new one is found to be full-screen or not.
            if (prev.finishing) {
                prev.setVisibility(false);
                if (DEBUG_SWITCH) Slog.v(TAG_SWITCH,
                        "Not waiting for visible to hide: " + prev
                        + ", nowVisible=" + next.nowVisible);
            } else {
                if (DEBUG_SWITCH) Slog.v(TAG_SWITCH,
                        "Previous already visible but still waiting to hide: " + prev
                        + ", nowVisible=" + next.nowVisible);
            }

        }

        // Launching this app's activity, make sure the app is no longer
        // considered stopped.
        try {
            mAtmService.getPackageManager().setPackageStoppedState(
                    next.packageName, false, next.mUserId); /* TODO: Verify if correct userid */
        } catch (RemoteException e1) {
        } catch (IllegalArgumentException e) {
            Slog.w(TAG, "Failed trying to unstop package "
                    + next.packageName + ": " + e);
        }

        // We are starting up the next activity, so tell the window manager
        // that the previous one will be hidden soon.  This way it can know
        // to ignore it when computing the desired screen orientation.
        boolean anim = true;
        final DisplayContent dc = taskDisplayArea.mDisplayContent;
        if (prev != null) {
            if (prev.finishing) {
                if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,
                        "Prepare close transition: prev=" + prev);
                if (mStackSupervisor.mNoAnimActivities.contains(prev)) {
                    anim = false;
                    dc.prepareAppTransition(TRANSIT_NONE, false);
                } else {
                    dc.prepareAppTransition(
                            prev.getTask() == next.getTask() ? TRANSIT_ACTIVITY_CLOSE
                                    : TRANSIT_TASK_CLOSE, false);
                }
                prev.setVisibility(false);
            } else {
                if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,
                        "Prepare open transition: prev=" + prev);
                if (mStackSupervisor.mNoAnimActivities.contains(next)) {
                    anim = false;
                    dc.prepareAppTransition(TRANSIT_NONE, false);
                } else {
                    dc.prepareAppTransition(
                            prev.getTask() == next.getTask() ? TRANSIT_ACTIVITY_OPEN
                                    : next.mLaunchTaskBehind ? TRANSIT_TASK_OPEN_BEHIND
                                            : TRANSIT_TASK_OPEN, false);
                }
            }
        } else {
            if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION, "Prepare open transition: no previous");
            if (mStackSupervisor.mNoAnimActivities.contains(next)) {
                anim = false;
                dc.prepareAppTransition(TRANSIT_NONE, false);
            } else {
                dc.prepareAppTransition(TRANSIT_ACTIVITY_OPEN, false);
            }
        }

        if (anim) {
            next.applyOptionsLocked();
        } else {
            next.clearOptionsLocked();
        }

        mStackSupervisor.mNoAnimActivities.clear();

        if (next.attachedToProcess()) {
            if (DEBUG_SWITCH) Slog.v(TAG_SWITCH, "Resume running: " + next
                    + " stopped=" + next.stopped
                    + " visibleRequested=" + next.mVisibleRequested);

            // If the previous activity is translucent, force a visibility update of
            // the next activity, so that it's added to WM's opening app list, and
            // transition animation can be set up properly.
            // For example, pressing Home button with a translucent activity in focus.
            // Launcher is already visible in this case. If we don't add it to opening
            // apps, maybeUpdateTransitToWallpaper() will fail to identify this as a
            // TRANSIT_WALLPAPER_OPEN animation, and run some funny animation.
            final boolean lastActivityTranslucent = lastFocusedStack != null
                    && (lastFocusedStack.inMultiWindowMode()
                    || (lastFocusedStack.mLastPausedActivity != null
                    && !lastFocusedStack.mLastPausedActivity.occludesParent()));

            // This activity is now becoming visible.
            if (!next.mVisibleRequested || next.stopped || lastActivityTranslucent) {
                next.setVisibility(true);
            }

            // schedule launch ticks to collect information about slow apps.
            next.startLaunchTickingLocked();

            ActivityRecord lastResumedActivity =
                    lastFocusedStack == null ? null : lastFocusedStack.mResumedActivity;
            final ActivityState lastState = next.getState();

            mAtmService.updateCpuStats();

            if (DEBUG_STATES) Slog.v(TAG_STATES, "Moving to RESUMED: " + next
                    + " (in existing)");

            next.setState(RESUMED, "resumeTopActivityInnerLocked");

            next.app.updateProcessInfo(false /* updateServiceConnectionActivities */,
                    true /* activityChange */, true /* updateOomAdj */,
                    true /* addPendingTopUid */);

            // Have the window manager re-evaluate the orientation of
            // the screen based on the new activity order.
            boolean notUpdated = true;

            // Activity should also be visible if set mLaunchTaskBehind to true (see
            // ActivityRecord#shouldBeVisibleIgnoringKeyguard()).
            if (shouldBeVisible(next)) {
                // We have special rotation behavior when here is some active activity that
                // requests specific orientation or Keyguard is locked. Make sure all activity
                // visibilities are set correctly as well as the transition is updated if needed
                // to get the correct rotation behavior. Otherwise the following call to update
                // the orientation may cause incorrect configurations delivered to client as a
                // result of invisible window resize.
                // TODO: Remove this once visibilities are set correctly immediately when
                // starting an activity.
                notUpdated = !mRootWindowContainer.ensureVisibilityAndConfig(next, getDisplayId(),
                        true /* markFrozenIfConfigChanged */, false /* deferResume */);
            }

            if (notUpdated) {
                // The configuration update wasn't able to keep the existing
                // instance of the activity, and instead started a new one.
                // We should be all done, but let's just make sure our activity
                // is still at the top and schedule another run if something
                // weird happened.
                ActivityRecord nextNext = topRunningActivity();
                if (DEBUG_SWITCH || DEBUG_STATES) Slog.i(TAG_STATES,
                        "Activity config changed during resume: " + next
                                + ", new next: " + nextNext);
                if (nextNext != next) {
                    // Do over!
                    mStackSupervisor.scheduleResumeTopActivities();
                }
                if (!next.mVisibleRequested || next.stopped) {
                    next.setVisibility(true);
                }
                next.completeResumeLocked();
                return true;
            }

            try {
                final ClientTransaction transaction =
                        ClientTransaction.obtain(next.app.getThread(), next.appToken);
                // Deliver all pending results.
                ArrayList<ResultInfo> a = next.results;
                if (a != null) {
                    final int N = a.size();
                    if (!next.finishing && N > 0) {
                        if (DEBUG_RESULTS) Slog.v(TAG_RESULTS,
                                "Delivering results to " + next + ": " + a);
                        transaction.addCallback(ActivityResultItem.obtain(a));
                    }
                }

                if (next.newIntents != null) {
                    transaction.addCallback(
                            NewIntentItem.obtain(next.newIntents, true /* resume */));
                }

                // Well the app will no longer be stopped.
                // Clear app token stopped state in window manager if needed.
                next.notifyAppResumed(next.stopped);

                EventLogTags.writeWmResumeActivity(next.mUserId, System.identityHashCode(next),
                        next.getTask().mTaskId, next.shortComponentName);

                next.setSleeping(false);
                mAtmService.getAppWarningsLocked().onResumeActivity(next);
                next.app.setPendingUiCleanAndForceProcessStateUpTo(mAtmService.mTopProcessState);
                next.clearOptionsLocked();
                transaction.setLifecycleStateRequest(
                        ResumeActivityItem.obtain(next.app.getReportedProcState(),
                                dc.isNextTransitionForward()));
                mAtmService.getLifecycleManager().scheduleTransaction(transaction);

                if (DEBUG_STATES) Slog.d(TAG_STATES, "resumeTopActivityLocked: Resumed "
                        + next);
            } catch (Exception e) {
                // Whoops, need to restart this activity!
                if (DEBUG_STATES) Slog.v(TAG_STATES, "Resume failed; resetting state to "
                        + lastState + ": " + next);
                next.setState(lastState, "resumeTopActivityInnerLocked");

                // lastResumedActivity being non-null implies there is a lastStack present.
                if (lastResumedActivity != null) {
                    lastResumedActivity.setState(RESUMED, "resumeTopActivityInnerLocked");
                }

                Slog.i(TAG, "Restarting because process died: " + next);
                if (!next.hasBeenLaunched) {
                    next.hasBeenLaunched = true;
                } else  if (SHOW_APP_STARTING_PREVIEW && lastFocusedStack != null
                        && lastFocusedStack.isTopStackInDisplayArea()) {
                    next.showStartingWindow(null /* prev */, false /* newTask */,
                            false /* taskSwitch */);
                }
                mStackSupervisor.startSpecificActivity(next, true, false);
                return true;
            }

            // From this point on, if something goes wrong there is no way
            // to recover the activity.
            try {
                next.completeResumeLocked();
            } catch (Exception e) {
                // If any exception gets thrown, toss away this
                // activity and try the next one.
                Slog.w(TAG, "Exception thrown during resume of " + next, e);
                next.finishIfPossible("resume-exception", true /* oomAdj */);
                return true;
            }
        } else {
            // Whoops, need to restart this activity!
            if (!next.hasBeenLaunched) {
                next.hasBeenLaunched = true;
            } else {
                if (SHOW_APP_STARTING_PREVIEW) {
                    next.showStartingWindow(null /* prev */, false /* newTask */,
                            false /* taskSwich */);
                }
                if (DEBUG_SWITCH) Slog.v(TAG_SWITCH, "Restarting: " + next);
            }
            if (DEBUG_STATES) Slog.d(TAG_STATES, "resumeTopActivityLocked: Restarting " + next);
            mStackSupervisor.startSpecificActivity(next, true, true);
        }

        return true;
    }
```
### 11.1分析
1. 先对上一个 Activity 执行了 pause 操作，然后判断当前要启动的 Activity 是否已经启动了  
2. 如果已经启动了，发送 `ResumeActivityItem` 事务给客户端，执行 resume 流程。  
3. 如果没有启动，继续调用 `ActivityStackSupervisor` 的 `startSpecificActivity()` 方法。  
4. 这里注意下，调用` startSpecificActivity() `方法前调用了 `next.showStartingWindow()` 来展示一个**window**，这就是冷启动时出现**白屏的原因**。

## Step 12. ActivityStackSupervisor.startSpecificActivity
```java
void startSpecificActivity(ActivityRecord r, boolean andResume, boolean checkConfig) {
    // Is this activity's application already running?
    final WindowProcessController wpc =
            mService.getProcessController(r.processName, r.info.applicationInfo.uid);

    boolean knownToBeDead = false;
    if (wpc != null && wpc.hasThread()) {
        try {
            realStartActivityLocked(r, wpc, andResume, checkConfig);
            return;
        } catch (RemoteException e) {
            Slog.w(TAG, "Exception when starting activity "
                    + r.intent.getComponent().flattenToShortString(), e);
        }

        // If a dead object exception was thrown -- fall through to
        // restart the application.
        knownToBeDead = true;
    }

    r.notifyUnknownVisibilityLaunchedForKeyguardTransition();

    final boolean isTop = andResume && r.isTopRunningActivity();
    mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? "top-activity" : "activity");
}
```
### 12.1 分析

里面调用了 (ATMS) ActivityTaskManagerService.startProcessAsync 
startSpecificActivity() 方法中通过 wpc.hasThread() 来判断 activity 所在的应用是否已经在运行，其内部是通过 IApplicationThread 是否已经被赋值来判断的，如果为 true，走 ActivityStackSupervisor 的realStartActivityLocked() 方法，即普通 Activity 的启动流程；否则需要调用 ATMS 的 startProcessAsync() 来创建应用进程。


## Step   13.ActivityTaskManagerService.startProcessAsync

```java
void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop,
        String hostingType) {
    try {
        if (Trace.isTagEnabled(TRACE_TAG_WINDOW_MANAGER)) {
            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, "dispatchingStartProcess:"
                    + activity.processName);
        }
        // Post message to start process to avoid possible deadlock of calling into AMS with the
        // ATMS lock held.
        final Message m = PooledLambda.obtainMessage(ActivityManagerInternal::startProcess,
                mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead,
                isTop, hostingType, activity.intent.getComponent());
        mH.sendMessage(m);
    } finally {
        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
    }
}

```
此时应用进程还不存在，需要调用 ATMS 的 startProcessAsync() 来创建应用进程：
这里使用Handler发送消息来启动进程，获取Message对象跟我们平时的使用方式不太一样，这里用到PooledLambda的obtainMessage()方法，实际就是调用了ActivityManagerInternal的startProcess()方法。
## 
ActivityManagerInternal是一个抽象类，它是ActivityManager本地系统服务接口
```java 
public abstract class ActivityManagerInternal {
    /** Starts a given process. */
    public abstract void startProcess(String processName, ApplicationInfo info,
            boolean knownToBeDead, boolean isTop, String hostingType, ComponentName hostingName);
}
```
ActivityManagerInternal的实现类为AMS的内部类LocalService，这样就把创建进程的请求传递给了AMS去处理。

LocalServices可以理解为是一个公开缓存池，内部使用ArrayMap来存储本地服务对象。SystemServer进程中每个服务都可以通过LocalServices的addService()方法注册到LocalServices中，需要使用时通过LocalServices的getService()获取注册的本地服务

# 三、应用程序进程启动阶段

## Step 14 AMS.LocalService.startProcess
```java
public void startProcess(String processName, ApplicationInfo info, boolean knownToBeDead,
        boolean isTop, String hostingType, ComponentName hostingName) {
    try {
        if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "startProcess:"
                    + processName);
        }
        synchronized (ActivityManagerService.this) {
            startProcessLocked(processName, info, knownToBeDead, 0 /* intentFlags */,
                    new HostingRecord(hostingType, hostingName, isTop),
                    ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE, false /* allowWhileBooting */,
                    false /* isolated */, true /* keepIfLarge */);
        }
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    }
}
```
接着会调用 startProcessLocked 方法：
## Step 15 AMS.startProcessLocked
```java
@GuardedBy("this")
final ProcessRecord startProcessLocked(String processName,
        ApplicationInfo info, boolean knownToBeDead, int intentFlags,
        HostingRecord hostingRecord, int zygotePolicyFlags, boolean allowWhileBooting,
        boolean isolated, boolean keepIfLarge) {
    return mProcessList.startProcessLocked(processName, info, knownToBeDead, intentFlags,
            hostingRecord, zygotePolicyFlags, allowWhileBooting, isolated, 0 /* isolatedUid */,
            keepIfLarge, null /* ABI override */, null /* entryPoint */,
            null /* entryPointArgs */, null /* crashHandler */);
}
```
接着调用 ProcessList 的 startProcessLocked 方法，进程启动成功会返回 true
## Step 16 ProcessList.startProcessLocked
```java
@GuardedBy("mService")
boolean startProcessLocked(ProcessRecord app, HostingRecord hostingRecord,
        int zygotePolicyFlags, boolean disableHiddenApiChecks, boolean disableTestApiChecks,
        String abiOverride) {
    ...
    try {
        ...
        // ProcessRecord 是一个描述进程的数据结构，记录着当前运行的进程的详细信息。
        // 获取要创建的应用程序进程的用户ID
        int uid = app.uid;
        int[] gids = null;
        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
        boolean externalStorageAccess = false;
        if (!app.isolated) {
            ...
            // 创建用户组 ID 并赋值
            gids = computeGidsForProcess(mountExternal, uid, permGids, externalStorageAccess);
        }
        ...
        // 应用程序进程主线程类名
        final String entryPoint = "android.app.ActivityThread";

        return startProcessLocked(hostingRecord, entryPoint, app, uid, gids,
                runtimeFlags, zygotePolicyFlags, mountExternal, seInfo, requiredAbi,
                instructionSet, invokeWith, startTime);
    } 
    ...
}

@GuardedBy("mService")
boolean startProcessLocked(HostingRecord hostingRecord, String entryPoint, ProcessRecord app,
        int uid, int[] gids, int runtimeFlags, int zygotePolicyFlags, int mountExternal,
        String seInfo, String requiredAbi, String instructionSet, String invokeWith,
        long startTime) {
    ...

    if (mService.mConstants.FLAG_PROCESS_START_ASYNC) {
        ...
    } else {
        try {
            // 启动应用程序进程
            final Process.ProcessStartResult startResult = startProcess(hostingRecord,
                    entryPoint, app,
                    uid, gids, runtimeFlags, zygotePolicyFlags, mountExternal, seInfo,
                    requiredAbi, instructionSet, invokeWith, startTime);
            handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,
                    startSeq, false);
        } catch (RuntimeException e) {
            Slog.e(ActivityManagerService.TAG, "Failure starting process "
                    + app.processName, e);
            app.setPendingStart(false);
            mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),
                    false, false, true, false, false, app.userId, "start failure");
        }
        return app.getPid() > 0;
    }
}

```
ProcessRecord 是一个描述进程的数据结构，记录着当前运行的进程的详细信息。

## Step 17 ProcessList.startProcess
```java
private Process.ProcessStartResult startProcess(HostingRecord hostingRecord, String entryPoint,
        ProcessRecord app, int uid, int[] gids, int runtimeFlags, int zygotePolicyFlags,
        int mountExternal, String seInfo, String requiredAbi, String instructionSet,
        String invokeWith, long startTime) {
    try {
        ...

        final Process.ProcessStartResult startResult;
        boolean regularZygote = false;
        if (hostingRecord.usesWebviewZygote()) {
            ...
        } else if (hostingRecord.usesAppZygote()) {
            ...
        } else {
            regularZygote = true;
            // 调用 Process 的 start 方法
            startResult = Process.start(entryPoint,
                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,
                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                    app.info.dataDir, invokeWith, app.info.packageName, zygotePolicyFlags,
                    isTopApp, app.getDisabledCompatChanges(), pkgDataInfoMap,
                    allowlistedAppDataInfoMap, bindMountAppsData, bindMountAppStorageDirs,
                    new String[]{PROC_START_SEQ_IDENT + app.getStartSeq()});
        }
        ...
        return startResult;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    }
}

```
## Step 18 Process.start
```java
    public static ProcessStartResult start(@NonNull final String processClass,
                                           @Nullable final String niceName,
                                           int uid, int gid, @Nullable int[] gids,
                                           int runtimeFlags,
                                           int mountExternal,
                                           int targetSdkVersion,
                                           @Nullable String seInfo,
                                           @NonNull String abi,
                                           @Nullable String instructionSet,
                                           @Nullable String appDataDir,
                                           @Nullable String invokeWith,
                                           @Nullable String packageName,
                                           int zygotePolicyFlags,
                                           boolean isTopApp,
                                           @Nullable long[] disabledCompatChanges,
                                           @Nullable Map<String, Pair<String, Long>>
                                                   pkgDataInfoMap,
                                           @Nullable Map<String, Pair<String, Long>>
                                                   whitelistedDataInfoMap,
                                           boolean bindMountAppsData,
                                           boolean bindMountAppStorageDirs,
                                           @Nullable String[] zygoteArgs) {
        return ZYGOTE_PROCESS.start(processClass, niceName, uid, gid, gids,
                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,
                    abi, instructionSet, appDataDir, invokeWith, packageName,
                    zygotePolicyFlags, isTopApp, disabledCompatChanges,
                    pkgDataInfoMap, whitelistedDataInfoMap, bindMountAppsData,
                    bindMountAppStorageDirs, zygoteArgs);
    }
```
调用 ZygoteProcess 的 start 方法，ZygoteProcess 用于保持与 Zygote 进程的通信状态：

这里暂时就不继续追踪了，后续再单独看这部分的内容

这里主要是调用Process.start接口来创建一个新的进程，新的进程会导入android.app.ActivityThread类，并且执行它的main函数每一个应用程序都有一个ActivityThread实例来对应的原因。

应用程序进程创建后，会反射调用 ActivityThread 的 main 方法

# 四、ActivityThread 初始化阶段
## Step 19 ActivityThread.main
```java 
public final class ActivityThread extends ClientTransactionHandler
        implements ActivityThreadInternal {
        
    // 初始化 ApplicationThread
    @UnsupportedAppUsage
    final ApplicationThread mAppThread = new ApplicationThread();
    
    @UnsupportedAppUsage
    final Looper mLooper = Looper.myLooper();
    
    // 初始化 Handler，给 ApplicationThread 与 ActivityThread 通信使用
    @UnsupportedAppUsage
    final H mH = new H();
    
    public static void main(String[] args) {
        ...
        // 主线程 Looper
        Looper.prepareMainLooper();

        // 初始化 ActivityThread
        ActivityThread thread = new ActivityThread();
        thread.attach(false, startSeq);

        if (sMainThreadHandler == null) {
            sMainThreadHandler = thread.getHandler();
        }

        if (false) {
            Looper.myLooper().setMessageLogging(new
                    LogPrinter(Log.DEBUG, "ActivityThread"));
        }

        // End of event ActivityThreadMain.
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        // 开启主线程 Looper 循环
        Looper.loop();

        throw new RuntimeException("Main thread loop unexpectedly exited");
    }
    
    @UnsupportedAppUsage
    private void attach(boolean system, long startSeq) {
        ...
        if (!system) {
            ...
            final IActivityManager mgr = ActivityManager.getService();
            try {
                mgr.attachApplication(mAppThread, startSeq);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
            ...
        }
    }
}

```
ActivityThread 的 attach 方法中使用 Binder 通信跨进程调用了 AMS 的 attachApplication() 方法，并将ApplicationThread 作为参数传递过去。

## Step 20 AMS.attachApplication->attachApplicationLocked

```java
@Override
public final void attachApplication(IApplicationThread thread, long startSeq) {
    if (thread == null) {
        throw new SecurityException("Invalid application interface");
    }
    synchronized (this) {
        int callingPid = Binder.getCallingPid();
        final int callingUid = Binder.getCallingUid();
        final long origId = Binder.clearCallingIdentity();
        attachApplicationLocked(thread, callingPid, callingUid, startSeq);
        Binder.restoreCallingIdentity(origId);
    }
}

@GuardedBy("this")
private boolean attachApplicationLocked(@NonNull IApplicationThread thread,
        int pid, int callingUid, long startSeq) {
    // 保存当前正在运行的进程的所有信息
    ProcessRecord app;
    ...
    try {
        ...
        if (app.getIsolatedEntryPoint() != null) {
            thread.runIsolatedEntryPoint(
                    app.getIsolatedEntryPoint(), app.getIsolatedEntryPointArgs());
        } else if (instr2 != null) {
            // 跨进程调用 ApplicationThread 的 bindApplication 创建绑定 Application
            thread.bindApplication(processName, appInfo, providerList,
                    instr2.mClass,
                    profilerInfo, instr2.mArguments,
                    instr2.mWatcher,
                    instr2.mUiAutomationConnection, testMode,
                    mBinderTransactionTrackingEnabled, enableTrackAllocation,
                    isRestrictedBackupMode || !normalMode, app.isPersistent(),
                    new Configuration(app.getWindowProcessController().getConfiguration()),
                    app.getCompat(), getCommonServicesLocked(app.isolated),
                    mCoreSettingsObserver.getCoreSettingsLocked(),
                    buildSerial, autofillOptions, contentCaptureOptions,
                    app.getDisabledCompatChanges(), serializedSystemFontMap);
        ...
        app.makeActive(thread, mProcessStats);
        ...
        }
    } catch (Exception e) {
        // We need kill the process group here. (b/148588589)
        Slog.wtf(TAG, "Exception thrown during bind of " + app, e);
        app.resetPackageList(mProcessStats);
        app.unlinkDeathRecipient();
        app.killLocked("error during bind", ApplicationExitInfo.REASON_INITIALIZATION_FAILURE,
                true);
        handleAppDiedLocked(app, pid, false, true, false /* fromBinderDied */);
        return;
    }
    if (normalMode) {
        try {
            didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown launching activities in " + app, e);
            badApp = true;
        }
    }
    ...
}
```
### 20.1 分析
AMS 的 attachApplication 方法在获取到 pid、uid 后继续调用 AMS 的 attachApplicationLocked 方法。AMS的 attachApplicationLocked 方法中关注以下流程：

1. 通过跨进程通信调用应用进程中 ApplicationThread 的 bindApplication 创建并绑定 Application。
2. 通过 mAtmInternal.attachApplication 本地服务过渡到 ATMS 启动根 Activity。

IApplicationThread 的 bindApplication 方法调用的是应用进程中的实现类 ApplicationThread 的bindApplication 方法

## Step 21 ApplicationThread.bindApplication

```java 
@Override
public final void bindApplication(String processName, ApplicationInfo appInfo,
        ProviderInfoList providerList, ComponentName instrumentationName,
        ProfilerInfo profilerInfo, Bundle instrumentationArgs,
        IInstrumentationWatcher instrumentationWatcher,
        IUiAutomationConnection instrumentationUiConnection, int debugMode,
        boolean enableBinderTracking, boolean trackAllocation,
        boolean isRestrictedBackupMode, boolean persistent, Configuration config,
        CompatibilityInfo compatInfo, Map services, Bundle coreSettings,
        String buildSerial, AutofillOptions autofillOptions,
        ContentCaptureOptions contentCaptureOptions, long[] disabledCompatChanges) {
    if (services != null) {
        if (false) {
            // Test code to make sure the app could see the passed-in services.
            for (Object oname : services.keySet()) {
                if (services.get(oname) == null) {
                    continue; // AM just passed in a null service.
                }
                String name = (String) oname;

                // See b/79378449 about the following exemption.
                switch (name) {
                    case "package":
                    case Context.WINDOW_SERVICE:
                        continue;
                }

                if (ServiceManager.getService(name) == null) {
                    Log.wtf(TAG, "Service " + name + " should be accessible by this app");
                }
            }
        }

        // Setup the service cache in the ServiceManager
        ServiceManager.initServiceCache(services);
    }

    setCoreSettings(coreSettings);

    AppBindData data = new AppBindData();
    data.processName = processName;
    data.appInfo = appInfo;
    data.providers = providerList.getList();
    data.instrumentationName = instrumentationName;
    data.instrumentationArgs = instrumentationArgs;
    data.instrumentationWatcher = instrumentationWatcher;
    data.instrumentationUiAutomationConnection = instrumentationUiConnection;
    data.debugMode = debugMode;
    data.enableBinderTracking = enableBinderTracking;
    data.trackAllocation = trackAllocation;
    data.restrictedBackupMode = isRestrictedBackupMode;
    data.persistent = persistent;
    data.config = config;
    data.compatInfo = compatInfo;
    data.initProfilerInfo = profilerInfo;
    data.buildSerial = buildSerial;
    data.autofillOptions = autofillOptions;
    data.contentCaptureOptions = contentCaptureOptions;
    data.disabledCompatChanges = disabledCompatChanges;
    sendMessage(H.BIND_APPLICATION, data);
}
```
bindApplication 方法中通过内部类 H 发送 Handler 消息，进而调用到 ActivityThread 的 handleBindApplication 

## Step 22 ActivityThread.handleBindApplication
```java
@UnsupportedAppUsage
// core/java/android/app/ActivityThread.java
private void handleBindApplication(AppBindData data) {
   ...
    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);
    mConfigurationController.updateLocaleListFromAppContext(appContext);

    ...
    if (ii != null) {
        initInstrumentation(ii, data, appContext);
    } else {
        mInstrumentation = new Instrumentation();
        mInstrumentation.basicInit(this);
    }

    ...
    Application app;
    ...
    try {
        // If the app is being launched for full backup or restore, bring it up in
        // a restricted environment with the base application class.
        // 创建 Application 
        app = data.info.makeApplication(data.restrictedBackupMode, null);

        // Propagate autofill compat state
        app.setAutofillOptions(data.autofillOptions);

        // Propagate Content Capture options
        app.setContentCaptureOptions(data.contentCaptureOptions);
        sendMessage(H.SET_CONTENT_CAPTURE_OPTIONS_CALLBACK, data.appInfo.packageName);

        mInitialApplication = app;
        final boolean updateHttpProxy;
        synchronized (this) {
            updateHttpProxy = mUpdateHttpProxyOnBind;
            // This synchronized block ensures that any subsequent call to updateHttpProxy()
            // will see a non-null mInitialApplication.
        }
        if (updateHttpProxy) {
            ActivityThread.updateHttpProxy(app);
        }

        // don't bring up providers in restricted mode; they may depend on the
        // app's custom Application class
        // 初始化ContentProvider，里面会构建ContentProvider实例并调用其onCreate()方法
        if (!data.restrictedBackupMode) {
            if (!ArrayUtils.isEmpty(data.providers)) {
                installContentProviders(app, data.providers);
            }
        }

        // Do this after providers, since instrumentation tests generally start their
        // test thread at this point, and we don't want that racing.
        try {
            mInstrumentation.onCreate(data.instrumentationArgs);
        }
        ...
        try {
            mInstrumentation.callApplicationOnCreate(app);
        } 
        ...
    }

    ...
}
```
在 handleBindApplication 方法中创建了 Instrumentation 实例和 Application 实例。  
ActivityThread 的 performLaunchActivity 方法中也有创建 Application 实例的操作，里面会先判断Application 是否已存在。  
**正常情况下 Application 的初始化是在 handleBindApplication 方法中的，并且是创建进程后调用的。performLaunchActivity 中只是做了一个检测，异常情况 Application 不存在时才会创建。**

App 端 bindApplication 运行完之后，回到前面的 AMS attachApplication 方法，继续调用mAtmInternal.attachApplication

## Step 23 ActivityTaskManagerService.attachApplication
```java
@HotPath(caller = HotPath.PROCESS_CHANGE)
@Override
public boolean attachApplication(WindowProcessController wpc) throws RemoteException {
    synchronized (mGlobalLockWithoutBoost) {
        if (Trace.isTagEnabled(TRACE_TAG_WINDOW_MANAGER)) {
            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, "attachApplication:" + wpc.mName);
        }
        try {
            return mRootWindowContainer.attachApplication(wpc);
        } finally {
            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
        }
    }
}
```
## Step 24 RootWindowContainer.attachApplication
```java
boolean attachApplication(WindowProcessController app) throws RemoteException {
    final String processName = app.mName;
    boolean didSomething = false;
    for (int displayNdx = getChildCount() - 1; displayNdx >= 0; --displayNdx) {
        final DisplayContent display = getChildAt(displayNdx);
        final ActivityStack stack = display.getFocusedStack();
        if (stack == null) {
            continue;
        }

        mTmpRemoteException = null;
        mTmpBoolean = false; // Set to true if an activity was started.
        final PooledFunction c = PooledLambda.obtainFunction(
                RootWindowContainer::startActivityForAttachedApplicationIfNeeded, this,
                PooledLambda.__(ActivityRecord.class), app, stack.topRunningActivity());
        stack.forAllActivities(c);
        c.recycle();
        if (mTmpRemoteException != null) {
            throw mTmpRemoteException;
        }
        didSomething |= mTmpBoolean;
    }
    if (!didSomething) {
        ensureActivitiesVisible(null, 0, false /* preserve_windows */);
    }
    return didSomething;
}
```
调用RootWindowContainer::startActivityForAttachedApplicationIfNeeded

## Step 25 RootWindowContainer.attachApplication
```java
private boolean startActivityForAttachedApplicationIfNeeded(ActivityRecord r,
        WindowProcessController app, ActivityRecord top) {
    if (r.finishing || !r.okToShowLocked() || !r.visibleIgnoringKeyguard || r.app != null
            || app.mUid != r.info.applicationInfo.uid || !app.mName.equals(r.processName)) {
        return false;
    }

    try {
        if (mStackSupervisor.realStartActivityLocked(r, app, top == r /*andResume*/,
                true /*checkConfig*/)) {
            mTmpBoolean = true;
        }
    } catch (RemoteException e) {
        Slog.w(TAG, "Exception in new application when starting activity "
                + top.intent.getComponent().flattenToShortString(), e);
        mTmpRemoteException = e;
        return true;
    }
    return false;
}
```
调用mStackSupervisor.realStartActivityLocked

# 五、Activity 启动阶段

## Step 26 ActivityStackSupervisor.realStartActivityLocked
```java
// ActivityStackSupervisor.java (Android 30)
boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc,
        boolean andResume, boolean checkConfig) throws RemoteException {
    // 构建客户端事务（ClientTransaction）
    final ClientTransaction clientTransaction = ClientTransaction.obtain(
            proc.getThread(), r.appToken);
    // 1. 添加 LaunchActivityItem（触发 Activity 实例化）
    clientTransaction.addCallback(LaunchActivityItem.obtain(
            new Intent(r.intent), r.appInfo,
            r.compat, r.launchedFromPackage,
            r.task.voiceInteractor, proc.getDisplayId(),
            r.config, r.overrideConfig, r.lastNonConfigurationInstances,
            r.activityResult, r.newIntents, r.takeFlags,
            andResume, proc.isIsolated(), r.isEmbedded(),
            r.createTaskToReturn, proc.getDisplayAreaInfo()));
    // 2. 设置生命周期状态为 RESUME（如需立即恢复）
    if (andResume) {
        final ActivityLifecycleItem lifecycleItem = ResumeActivityItem.obtain(
                proc.getDisplayContent().isNextTransitionForward());
        clientTransaction.setLifecycleStateRequest(lifecycleItem);
    }
    // 3. 发送事务到应用进程（通过 Binder 调用 ApplicationThread）
    mService.getLifecycleManager().scheduleTransaction(clientTransaction);
    return true;// 启动成功
}
```
scheduleTransaction 最终通过 Binder 调用应用进程 ActivityThread 的 scheduleTransaction 方法。

## Step 27 ActivityThread.scheduleTransaction
调用 ActivityThread 的 scheduleTransaction 方法：
```java
@Override
public void scheduleTransaction(ClientTransaction transaction) throws RemoteException {
    ActivityThread.this.scheduleTransaction(transaction);
}
//ClientTransactionHandler
void scheduleTransaction(ClientTransaction transaction) {
    transaction.preExecute(this);
    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);
}
```
最终调用到 ActivityThread 的 sendMessage：
## Step 28 ActivityThread.sendMessage
```java 
private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {
    if (DEBUG_MESSAGES) {
        Slog.v(TAG,
                "SCHEDULE " + what + " " + mH.codeToString(what) + ": " + arg1 + " / " + obj);
    }
    Message msg = Message.obtain();
    msg.what = what;
    msg.obj = obj;
    msg.arg1 = arg1;
    msg.arg2 = arg2;
    if (async) {
        msg.setAsynchronous(true);
    }
    mH.sendMessage(msg);
}
```
最后调用了 mH.sendMessage(msg)，mH 是一个 Handler 对象，mH 是在主线程创建的，所以通过 mH.sendMessage(msg) 把消息发送到了主线程。
那么前面 ApplicationThread 的 scheduleTransaction 方法执行在哪个线程呢？根据 IPC 知识，服务器的 Binder 方法运行在 Binder 线程池中，也就是说系统进行跨进程调用 ApplicationThread 的 scheduleTransaction 方法运行在 Binder 的线程池中，这样就把子线程中的消息通过 Handler 发送到了主线程。继续看 ActivityThread.H 的 handleMessage 方法：

## Step 29 ActivityThread.H.handleMessage
```java
private final TransactionExecutor mTransactionExecutor = new TransactionExecutor(this);
public void handleMessage(Message msg) {
    if (DEBUG_MESSAGES) Slog.v(TAG, ">>> handling: " + codeToString(msg.what));
    switch (msg.what) {
        ...
        case EXECUTE_TRANSACTION:
            final ClientTransaction transaction = (ClientTransaction) msg.obj;
            mTransactionExecutor.execute(transaction);
            if (isSystem()) {
                // Client transactions inside system process are recycled on the client side
                // instead of ClientLifecycleManager to avoid being cleared before this
                // message is handled.
                transaction.recycle();
            }
            // TODO(lifecycler): Recycle locally scheduled transactions.
            break;
        ...
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES) Slog.v(TAG, "<<< done: " + codeToString(msg.what));
}

```
handleMessage 获取到 EXECUTE_TRANSACTION，执行 TransactionExecutor 的 execute 方法：

## Step 30 TransactionExecutor.execute
```java
// TransactionExecutor.java (Android 30)
public void execute(ClientTransaction transaction) {
    // 1. 执行事务中的回调指令（如 LaunchActivityItem）
    executeCallbacks(transaction);
    // 2. 执行生命周期状态请求（如 RESUME）
    executeLifecycleState(transaction);
}
```
executeCallbacks 会遍历事务中的回调，执行 LaunchActivityItem 的 execute 方法

## Step 31 LaunchActivityItem.execute
```java
// LaunchActivityItem.java (Android 30)
@Override
public void execute(ClientTransactionHandler client, IBinder token,
        PendingTransactionActions pendingActions) {
    ActivityThread activityThread = (ActivityThread) client;
    // 获取 ActivityClientRecord（封装 Activity 启动信息）
    ActivityClientRecord r = new ActivityClientRecord(token, mIntent, ...);
    // 触发 Activity 启动核心逻辑
    activityThread.handleLaunchActivity(r, pendingActions, null /* customIntent */);
}
```

## Step 32. ActivityThread.handleLaunchActivity
```java
// ActivityThread.java (Android 30)
private void handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions,
        Intent customIntent) {
    // 初始化 WindowManager 等系统服务
    configureWindowManager(r);
    // 核心：实例化并启动 Activity
    Activity a = performLaunchActivity(r, customIntent);
    if (a != null) {
        // 处理 Activity 恢复逻辑
        handleResumeActivity(r.token, false /* finalStateRequest */, r.isForward,
                !r.activity.mFinished && !r.startsNotResumed);
    }
}
```
## Step 33. ActivityThread.performLaunchActivity（Activity 实例化核心）
```java 
// ActivityThread.java (Android 30)
private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    // 1. 获取 ActivityInfo（从 AndroidManifest 解析的信息）
    ActivityInfo aInfo = r.activityInfo;
    if (aInfo == null) {
        throw new RuntimeException("ActivityInfo is null");
    }
    // 2. 创建 ContextImpl（Activity 上下文）
    ContextImpl appContext = createBaseContextForActivity(r);
    Activity activity = null;
    try {
        // 3. 通过类加载器反射创建 Activity 实例
        java.lang.ClassLoader cl = appContext.getClassLoader();
        activity = mInstrumentation.newActivity(cl, aInfo.name, r.intent);
    } catch (Exception e) {
        // 异常处理
    }

    try {
        // 4. 获取或创建 Application 实例（确保全局唯一）
        Application app = r.packageInfo.makeApplication(false, mInstrumentation);
        
        // 5. 关联 Activity 与上下文、Application
        activity.attach(appContext, this, getInstrumentation(), r.token,
                r.ident, app, r.intent, aInfo, r.title, r.parent,
                r.embeddedID, r.lastNonConfigurationInstances, config,
                r.referrer, r.voiceInteractor, window, r.configCallback);
        
        // 6. 触发 Activity.onCreate()
        if (r.isPersistable()) {
            mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
        } else {
            mInstrumentation.callActivityOnCreate(activity, r.state);
        }
    } catch (Exception e) {
        // 异常处理
    }

    return activity;
}
```
performLaunchActivity()主要完成以下事情：

1. 从 ActivityClientRecord 中获取待启动的 Activity 的组件信息。
2. 通过 mInstrumentation.newActivity 方法使用类加载器创建 activity 实例。
3. 通过 LoadedApk 的 makeApplication 方法创建 Application 对象，内部也是通过 mInstrumentation 使用类加载器来创建的，创建后调用了 instrumentation.callApplicationOnCreate 方法，也就是 Application 的 onCreate()方法。
4. 调用 Activity 的 onCreate 方法，是通过 mInstrumentation.callActivityOnCreate 方法完成。

## Step 34. ActivityThread.performLaunchActivity
 在 performLaunchActivity 完成 Activity 实例化和 onCreate 调用后，ActivityThread 会通过 Instrumentation 触发 
```java
// ActivityThread.java (Android 30)
private void handleStartActivity(ActivityClientRecord r, PendingTransactionActions pendingActions) {
    final Activity activity = r.activity;
    // 标记 Activity 状态为 STARTED
    r.setState(ON_START);
    
    // 调用 Instrumentation 触发 onStart
    mInstrumentation.callActivityOnStart(activity);
    
    // 处理 pendingActions（如权限请求、结果返回）
    if (pendingActions != null) {
        pendingActions.setStartedActivity(true);
    }
    
    // 触发 Activity.onPostCreate（若有）
    if (r.isPersistable()) {
        mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState);
    } else {
        mInstrumentation.callActivityOnPostCreate(activity, r.state);
    }
}
```
1. 调用 Activity.onStart()，使 Activity 进入可见状态；
2. 衔接 onCreate 与 onResume，完成生命周期的过渡；
3. 处理配置变更、权限请求等 pending 操作。

Step 35. ActivityThread.handleResumeActivity（触发 onResume）

``` java
// ActivityThread.java (Android 30)
final void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,
        boolean shouldSendResume) {
    // 1. 执行 Activity.onResume()
    ActivityClientRecord r = performResumeActivity(token, finalStateRequest, isForward);
    if (r != null && r.activity != null) {
        // 2. 显示 Activity 窗口（与 WMS 交互）
        if (r.window == null && !a.mFinished && willBeVisible) {
            r.window = r.activity.getWindow();
            View decor = r.window.getDecorView();
            decor.setVisibility(View.INVISIBLE);
            ViewManager wm = a.getWindowManager();
            WindowManager.LayoutParams l = r.window.getAttributes();
            wm.addView(decor, l); // 将 DecorView 添加到 WindowManager
        }
        // 3. 触发 onPostResume()
        mInstrumentation.callActivityOnPostResume(r.activity);
    }
}
```

# 启动流程总结
从 Launcher 点击应用图标到 Activity 显示的完整链路：
1. Launcher 阶段：通过 startActivitySafely 发起启动请求，经 Instrumentation 调用 ATMS；
2. AMS 处理阶段：解析 Intent、创建 ActivityRecord、调度任务栈，最终触发应用进程启动；
3. 应用进程启动阶段：Zygote 孵化进程，初始化 ActivityThread 并绑定 Application；
4. Activity 实例化阶段：通过 ClientTransaction 触发 performLaunchActivity 实例化 Activity，依次调用 onCreate() → onStart() → onResume()，最终显示界面。




## 旧版分析总结
之前版本的流程分析，核心内容没变，分析记忆方便些
 **MainActivity 启动全流程的文字步骤拆解**（按执行顺序划分核心阶段，每个步骤包含「操作主体+核心动作+组件交互」

# MainActivity 启动全流程
## 一、阶段一：Launcher 发起启动请求（用户点击应用图标后）
1. **Launcher 触发点击事件**：用户点击应用图标，Launcher 的 `onClick` 方法调用 `startActivitySafely`，构建包含 `android.intent.action.MAIN` 和 `android.intent.category.LAUNCHER` 的 Intent，并添加 `FLAG_ACTIVITY_NEW_TASK` 标志。
2. **Activity 层转发请求**：通过 `Activity.startActivity` → `Activity.startActivityForResult` 转发，最终调用 `mInstrumentation.execStartActivity`（Instrumentation 作为系统与应用的桥梁）。
3. **跨进程调用 AMS**：`Instrumentation` 获取 AMS 的远程代理 `ActivityManagerProxy`，通过 Binder 通信调用 `ActivityManagerProxy.startActivity`，将请求发送到系统进程的 `ActivityManagerService`（AMS）。
4. **AMS 栈管理预处理**：
   - AMS 调用 `ActivityStack.startActivityMayWait`，解析目标 Activity 的 `ActivityInfo`（从 AndroidManifest 中获取）。
   - 依次执行 `ActivityStack.startActivityLocked`（创建 `ActivityRecord` 记录 Activity 状态）→ `ActivityStack.startActivityUncheckedLocked`（创建新 Task 用于存放 MainActivity）。
   - 调用 `ActivityStack.resumeTopActivityLocked`，检测到当前活跃的是 Launcher，需先暂停 Launcher。

## 二、阶段二：暂停前序 Activity（Launcher 进入 Paused 状态）
5. **AMS 通知 Launcher 暂停**：`ActivityStack.startPausingLocked` 通过 `ApplicationThreadProxy.schedulePauseActivity`（AMS 到 Launcher 进程的 Binder 代理）发送暂停请求。
6. **Launcher 进程处理暂停**：
   - Binder 通信将请求传递到 Launcher 进程的 `ApplicationThread`，其发送 `PAUSE_ACTIVITY` 消息到 `ActivityThread` 的消息队列。
   - `ActivityThread` 的 Handler `H` 处理消息，调用 `ActivityThread.handlePauseActivity`，最终执行 Launcher 的 `onPause` 生命周期方法。
7. **通知 AMS 暂停完成**：Launcher 暂停后，通过 `ActivityManagerProxy.activityPaused` 向 AMS 反馈“已暂停”，完成跨进程通信闭环。

## 三、阶段三：AMS 创建 MainActivity 所属进程
8. **AMS 触发进程创建**：AMS 收到 Launcher 暂停反馈后，执行 `ActivityStack.activityPaused` → `ActivityStack.completePauseLocked`，再次调用 `ActivityStack.resumeTopActivityLocked`，检测到 MainActivity 对应的进程未创建，触发 `ActivityStack.startSpecificActivityLocked`。
9. **AMS 发起进程创建请求**：`ActivityManagerService.startProcessLocked` 调用 `Process.start`（底层通过 `fork/exec` 系统调用），创建新的应用进程（MainActivity 运行在该进程中）。
10. **新进程初始化**：
    - 新进程启动后，执行 `ActivityThread.main` 方法（应用进程的入口），初始化 `ActivityThread`、创建主线程消息队列。
    - 调用 `ActivityThread.attach` 方法，通过 `ActivityManagerProxy.attachApplication` 将 `ApplicationThread`（应用进程的 Binder 服务端）传递给 AMS，建立 AMS 与新进程的通信链路。

## 四、阶段四：AMS 与新进程绑定通信
11. **AMS 绑定进程与 Activity**：AMS 收到 `attachApplication` 请求后，执行 `ActivityManagerService.attachApplicationLocked`，将新进程的 `ProcessRecord`（进程状态记录）与 MainActivity 的 `ActivityRecord` 绑定。
12. **确认启动目标**：AMS 从栈顶获取 MainActivity 的 `ActivityRecord`，准备发起 Activity 启动指令。

## 五、阶段五：启动 MainActivity 并执行生命周期
13. **AMS 通知新进程启动 Activity**：`ActivityStack.realStartActivityLocked` 通过 `ApplicationThreadProxy.scheduleLaunchActivity`（AMS 到新进程的 Binder 代理）发送启动请求，携带 `ActivityRecord` 中的配置信息（如组件名、Intent、主题等）。
14. **新进程处理启动请求**：
    - Binder 通信将请求传递到新进程的 `ApplicationThread`，其创建 `ActivityClientRecord`（封装 Activity 启动信息），并发送 `LAUNCH_ACTIVITY` 消息到 `ActivityThread` 的消息队列。
    - 主线程 Handler `H` 处理 `LAUNCH_ACTIVITY` 消息，调用 `ActivityThread.handleLaunchActivity`。
15. **初始化 Activity 上下文**：`ActivityThread.performLaunchActivity` 执行核心初始化：
    - 加载 MainActivity 类（通过类加载器 `ClassLoader`）。
    - 创建 `Application` 实例（若未创建），初始化 `ContextImpl`（Activity 的上下文）。
    - 调用 `Activity.attach` 方法，将上下文、`ActivityManagerProxy` 等绑定到 MainActivity。
16. **执行 MainActivity 生命周期**：`mInstrumentation.callActivityOnCreate` 调用 MainActivity 的 `onCreate` 方法，加载布局、初始化控件，后续依次执行 `onStart` → `onResume`，MainActivity 最终显示在屏幕上。

## 核心流程总结（简化版）
用户点击图标 → Launcher 发起请求 → AMS 暂停 Launcher → AMS 创建新进程 → 新进程与 AMS 绑定 → AMS 通知新进程启动 Activity → 新进程初始化 Activity 并执行生命周期 → MainActivity 显示。

## 关键跨进程通信（IPC）点
1. Launcher 进程 → 系统进程（AMS）：通过 `ActivityManagerProxy` 发起启动请求。
2. 系统进程（AMS）→ Launcher 进程：通过 `ApplicationThreadProxy` 通知暂停。
3. 新进程 → 系统进程（AMS）：通过 `ActivityManagerProxy` 绑定 `ApplicationThread`。
4. 系统进程（AMS）→ 新进程：通过 `ApplicationThreadProxy` 通知启动 Activity。

## 应用内启动
主要是在startActivityUncheckedLocked 里面判断参数intent的标志位**Intent.FLAG_ACTIVITY_NEW_TASK**没有设置，启动模式launchMode也是普通模式时，r.task = sourceRecord.task ，运行在同一个Task中,然后不会调用AMS.startProcessLocked,后续startSpecificActivityLocked时，getProcessRecordLocked不为空，所以直接执行realStartActivityLocked




