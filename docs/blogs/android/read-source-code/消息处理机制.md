---
title: android 消息处理机制Looper&Handler
date: 2025-11-30
categories:
  - android
tags:
  - android
  - 源码分析
---

#  Android应用程序消息处理机制（Looper、Handler）分析

***
跟着老罗的分享学习Android应用程序消息处理机制（Looper、Handler）分析
 [原文地址](https://blog.csdn.net/Luoshengyang/article/details/6817933)
***

handler工作中频繁使用，来看下源码学习下
工作中经常有使用handler完成线程切换，先按照主线程查看
private static Handler handler = new Handler(Looper.getMainLooper());

Android应用程序进程在启动的时候，会在进程中加载ActivityThread类，并且执行这个类的main函数，应用程序的消息循环过程就是在这个main函数里面实现的。

## 主线程的loop ActivityThread.main
```java
public final class ActivityThread {
	......
	public static final void main(String[] args) {
		......
		Looper.prepareMainLooper();
		......
		ActivityThread thread = new ActivityThread();
		thread.attach(false);
		......
		Looper.loop();
		......
		thread.detach();
		......
	}
}
```
main中主要做了两件事情，一是在主线程中创建了一个ActivityThread实例，二是通过Looper类使主线程进入消息循环中。  

先看下Looper.prepareMainLooper();

## 先看下Looper.prepareMainLooper();
在Looper文件中几个相关方法如下
```java
static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();
private static Looper sMainLooper;  // guarded by Looper.class
final MessageQueue mQueue;

private Looper(boolean quitAllowed) {
    mQueue = new MessageQueue(quitAllowed);
    mThread = Thread.currentThread();
}

public static void prepareMainLooper() {
    prepare(false);
    synchronized (Looper.class) {
        if (sMainLooper != null) {
            throw new IllegalStateException("The main Looper has already been prepared.");
        }
        sMainLooper = myLooper();
    }
}

private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException("Only one Looper may be created per thread");
    }
    sThreadLocal.set(new Looper(quitAllowed));
}

public static @Nullable Looper myLooper() {
    return sThreadLocal.get();
}

```

prepareMainLooper其实就是在线程中创建了一个Looper对象，这个对象是存放在sThreadLocal成员变量里面的，成员变量sThreadLocal的类型为**ThreadLocal**,表示这是一个**线程的局部变量**，既保证每一个调用prepareMainLooper的线程里面都有一个**独立的Looper对象**。   
在prepare中sThreadLocal.set(new Looper(quitAllowed))，先创建Looper对象，Looper构造函数里面可以看到，创建了一个消息队列**MessageQueue**,保存为Looper的成员变量，后续消息就是存放在这个队列中。   
消息队列是Android消息处理机制中最重要的组件，看下MessageQueue的创建过程

## MessageQueue 创建 
```java
public class MessageQueue {
	......
	private int mPtr; // used by native code
  private native static long nativeInit();
  MessageQueue(boolean quitAllowed) {
      mQuitAllowed = quitAllowed;
      mPtr = nativeInit();
  }
	......
}
```
初始化工作交给了JNI方法nativeInit()实现,暂时没学cpp，后续学习后再重新学习下

主要就是在内部创建了一个Looper对象，这个Looper对象是创建在**JNI层**的，和java中的Looper是不一样的，不过他们是对应的，后面分析消息循环过程时可以清晰了解到它们的关系。

把消息队列对象保存在Java层中创建的MessageQueue对象的mPtr成员变量里面

NativeMessageQueue的构造函数，JNI层Looper对象的创建流程（构造函数），做的事情非常重要，它跟我们后面要介绍的应用程序主线程在消息队列中没有消息时要进入**等待状态**以及当消息队列有消息时要把应用程序**主线程唤醒**的这两个知识点息息相关。
它主要就是通过pipe系统调用来创建了一个管道了
管道是Linux系统中的一种进程间通信机制，具体可以参考前面一篇文章 Android学习启动篇推荐的一本书《Linux内核源代码情景分析》中的第6章--传统的Uinx进程间通信。简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，别一个是用来写的，一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态，而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。这个等待和唤醒的操作是如何进行的呢，这就要借助**Linux**系统中的**epoll机制**了。 Linux系统中的epoll机制为处理大批量句柄而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。但是这里我们其实只需要监控的IO接口只有mWakeReadPipeFd一个，即前面我们所创建的管道的读端，为什么还需要用到epoll呢？有点用牛刀来杀鸡的味道。其实不然，这个Looper类是非常强大的，它除了监控内部所创建的管道接口之外，还提供了addFd接口供外界面调用，外界可以通过这个接口把自己想要监控的IO事件一并加入到这个Looper对象中去，当所有这些被监控的IO接口上面有事件发生时，就会唤醒相应的线程来处理，不过这里我们只关心刚才所创建的管道的IO事件的发生。


主要流程为：  
A. 在Java层，创建了一个Looper对象，这个Looper对象是用来进入消息循环的，它的内部有一个消息队列MessageQueue对象mQueue；

B. 在JNI层，创建了一个NativeMessageQueue对象，这个NativeMessageQueue对象保存在Java层的消息队列对象mQueue的成员变量mPtr中；

C. 在C++层，创建了一个Looper对象，保存在JNI层的NativeMessageQueue对象的成员变量mLooper中，这个对象的作用是，当Java层的消息队列中没有消息时，就使Android应用程序主线程进入等待状态，而当Java层的消息队列中来了新的消息后，就唤醒Android应用程序的主线程来处理这个消息。

## Looper.loop() 执行循环
 回到ActivityThread类的main函数中，在上面这些工作都准备好之后，就调用Looper类的loop函数进入到消息循环中去了：
 ```java 
 public class Looper {
	......
	public static final void loop() {
		Looper me = myLooper();
		MessageQueue queue = me.mQueue;
		......
		while (true) {
			Message msg = queue.next(); // might block
			......
			if (msg != null) {
				if (msg.target == null) {
					// No target is a magic identifier for the quit message.
					return;
				}
				......
				msg.target.dispatchMessage(msg);
				......
				msg.recycle();
			}
		}
	}
	......
}
 ```
 进入循环，不停从消息队列mQueue中去获取下一个要处理的消息msg，如果消息的target成员变量为null，就表示要退出循环，否则就要调用这个target对象的dispatchMessage成员函数来处理这个消息，这个targegt对象的类型为Handler，下面分析消息发送时会看到这个消息对象msg是如何设置的。

##  MessageQueue.next()
```java
public class MessageQueue {
	......
	final Message next() {
		int pendingIdleHandlerCount = -1; // -1 only during first iteration
		int nextPollTimeoutMillis = 0;
 
		for (;;) {
			if (nextPollTimeoutMillis != 0) {
				Binder.flushPendingCommands();
			}
			nativePollOnce(mPtr, nextPollTimeoutMillis);
			synchronized (this) {
				// Try to retrieve the next message.  Return if found.
				final long now = SystemClock.uptimeMillis();
				final Message msg = mMessages;
				if (msg != null) {
					final long when = msg.when;
					if (now >= when) {
						mBlocked = false;
						mMessages = msg.next;
						msg.next = null;
						if (Config.LOGV) Log.v("MessageQueue", "Returning message: " + msg);
						return msg;
					} else {
						nextPollTimeoutMillis = (int) Math.min(when - now, Integer.MAX_VALUE);
					}
				} else {
					nextPollTimeoutMillis = -1;
				}
				// If first time, then get the number of idlers to run.
				if (pendingIdleHandlerCount < 0) {
					pendingIdleHandlerCount = mIdleHandlers.size();
				}
				if (pendingIdleHandlerCount == 0) {
					// No idle handlers to run.  Loop and wait some more.
					mBlocked = true;
					continue;
				}
				if (mPendingIdleHandlers == null) {
					mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
				}
				mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
			}
			// Run the idle handlers.
			// We only ever reach this code block during the first iteration.
			for (int i = 0; i < pendingIdleHandlerCount; i++) {
				final IdleHandler idler = mPendingIdleHandlers[i];
				mPendingIdleHandlers[i] = null; // release the reference to the handler
 
				boolean keep = false;
				try {
					keep = idler.queueIdle();
				} catch (Throwable t) {
					Log.wtf("MessageQueue", "IdleHandler threw exception", t);
				}
				if (!keep) {
					synchronized (this) {
						mIdleHandlers.remove(idler);
					}
				}
			}
			// Reset the idle handler count to 0 so we do not run them again.
			pendingIdleHandlerCount = 0;
			// While calling an idle handler, a new message could have been delivered
			// so go back and look again for a pending message without waiting.
			nextPollTimeoutMillis = 0;
		}
	}
	......
}
```
调用这个函数的时候，有可能会让线程进入等待状态。什么情况下，线程会进入等待状态呢？两种情况，一是当消息队列中没有消息时，它会使线程进入等待状态；二是消息队列中有消息，但是消息指定了执行的时间，而现在还没有到这个时间，线程也会进入等待状态。消息队列中的消息是按时间先后来排序的，后面我们在分析消息的发送时会看到。

里面有一个**IdleHandlers**,在做启动优化时可以用到。  
执行 **nativePollOnce** 看当前消息队列中有没有消息
`nativePollOnce(mPtr, nextPollTimeoutMillis);`

这是一个JNI方法，这里传入的参数mPtr就是指向前面我们在JNI层创建的NativeMessageQueue对象了，而参数nextPollTimeoutMillis则表示如果当前消息队列中没有消息，它要等待的时候，for循环开始时，传入的值为0，表示不等待。

当前nativePollOnce返回后，就去看看消息队列中有没有消息：
```java
final Message msg = mMessages;
if (msg != null) {
	final long when = msg.when;
	if (now >= when) {
		mBlocked = false;
		mMessages = msg.next;
		msg.next = null;
		if (Config.LOGV) Log.v("MessageQueue", "Returning message: " + msg);
		return msg;
	} else {
		nextPollTimeoutMillis = (int) Math.min(when - now, Integer.MAX_VALUE);
	}
} else {
	nextPollTimeoutMillis = -1;
}
```
如果消息队列中有消息，并且当前时候大于等于消息中的执行时间，那么就直接返回这个消息给Looper.loop消息处理，否则的话就要等待到消息的执行时间：`nextPollTimeoutMillis = (int) Math.min(when - now, Integer.MAX_VALUE);`  
如果消息队列中没有消息，那就要进入无穷等待状态直到有新消息了：`nextPollTimeoutMillis = -1;`-1表示下次调用nativePollOnce时，如果消息中没有消息，就进入无限等待状态中去。这里计算出来的等待时间都是在下次调用nativePollOnce时使用的。

这里说的等待，是空闲等待，而不是忙等待，因此，在进入空闲等待状态前，如果应用程序注册了**IdleHandler**接口来处理一些事情，那么就会先执行这里IdleHandler，然后再进入等待状态。IdlerHandler是定义在MessageQueue的一个内部类,它只有一个成员函数queueIdle,执行这个函数时，如果返回值为**false移除这个IdleHandler**，否则的话就会在应用程序中继续维护着这个IdleHandler，下次空闲时仍会再执会这个IdleHandler。MessageQueue提供了addIdleHandler和removeIdleHandler两注册和删除IdleHandler。

如果没有，即pendingIdleHandlerCount等于0，那下面的逻辑就不执行了，通过continue语句直接进入下一次循环，否则就要把注册在mIdleHandlers中的IdleHandler取出来，放在mPendingIdleHandlers数组中去,接下来就是执行这些注册了的IdleHanlder了

执行完这些IdleHandler之后，线程下次调用JNI nativePollOnce函数时，就不设置超时时间了，因为，很有可能在执行IdleHandler的时候，已经有新的消息加入到消息队列中去了，因此，要重置nextPollTimeoutMillis的值`nextPollTimeoutMillis = 0`

## Handler.sendMessage
```java
public class Handler {
  final MessageQueue mQueue;
	final Looper mLooper;
  public Handler() {
		......
		mLooper = Looper.myLooper();
		......
		mQueue = mLooper.mQueue;
		......
  }
  ......
	public final boolean sendMessage(Message msg)
	{
		return sendMessageDelayed(msg, 0);
	}
	public final boolean sendMessageDelayed(Message msg, long delayMillis)
	{
		if (delayMillis < 0) {
			delayMillis = 0;
		}
		return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
	}
	public boolean sendMessageAtTime(Message msg, long uptimeMillis)
	{
		boolean sent = false;
		MessageQueue queue = mQueue;
		if (queue != null) {
			msg.target = this;
			sent = queue.enqueueMessage(msg, uptimeMillis);
		}
		else {
			......
		}
		return sent;
	}
	......
}
```
在发送消息时，是可指定消息处理时间的，使用sendMessage传入时间为0表示要马上处理，不要延时，在sendMessageDelayed中会获取当前时间，加上延时时间，获取到消息的绝对时间，调用sendMessageAtTime,将消息加入消息队列中。

在sendMessageAtTime中，首先获取消息队列mQueue,这是在Handler对象构造时初始好的，接着设置这个消息的目标对象target，即这个消息最终由谁处理**msg.target = this**这里将它赋值为this，即表示这个消息最终由这个Handler对象来处理

函数最后调用queue.enqueueMessage来把这个消息加入到应用程序的消息队列中去

## MessageQueue.enqueueMessage

```java
public class MessageQueue {
	......
	final boolean enqueueMessage(Message msg, long when) {
		......
		final boolean needWake;
		synchronized (this) {
			......
			msg.when = when;
			//Log.d("MessageQueue", "Enqueing: " + msg);
			Message p = mMessages;
			if (p == null || when == 0 || when < p.when) {
				msg.next = p;
				mMessages = msg;
				needWake = mBlocked; // new head, might need to wake up
			} else {
				Message prev = null;
				while (p != null && p.when <= when) {
					prev = p;
					p = p.next;
				}
				msg.next = prev.next;
				prev.next = msg;
				needWake = false; // still waiting on head, no need to wake up
			}
		}
		if (needWake) {
			nativeWake(mPtr);
		}
		return true;
	}
 
}
```
把消息加到消息队列时，分两种情况
1. 当前消息队列为空，这时候应用程序的主线程一般处于空闲等待状态，需要唤醒它
2. 当前消息队列不为空，不需唤醒主线程   
第一种情况比较简单，只需要把消息放在消息队列列头就可以了
```java
msg.next = p;
mMessages = msg;
needWake = mBlocked;
```  
把消息加入到消息队列去后，如果应用程序的主线程正处于空闲等待状态，就需要调用natvieWake函数来唤醒它了，这是一个JNI方法
  
第二种情况比较复杂，消息发送时可以指定时间，消息队列就是按照时间从小到大排序，新消息入列时需要找到合适位置再放入
```java
Message prev = null;
while (p != null && p.when <= when) {
	prev = p;
	p = p.next;
}
msg.next = prev.next;
prev.next = msg;
needWake = false; // still waiting on head, no need to wake up
```

## dispatchMessage消息处理
前面在分析消息循环时，说到应用程序的主线程是在Looper类的loop成员函数中进行消息循环过程的
```java
public class Looper {
	......
	public static final void loop() {
		Looper me = myLooper();
		MessageQueue queue = me.mQueue;
		......
		while (true) {
			Message msg = queue.next(); // might block
			......
			if (msg != null) {
				if (msg.target == null) {
					// No target is a magic identifier for the quit message.
					return;
				}
				......
				msg.target.dispatchMessage(msg);
				......
				msg.recycle();
			}
		}
	}
	......
}
```
从消息队列中获取到消息对象msg后，就会调用它的target成员变量的dispatchMessage函数来处理这个消息，在前面分析消息发送时说过，这个消息对象msg的成员变量target是在发送消息的时候设置好的，一般就通过哪个handler发送消息，就由哪个handler来处理消息。

## 总结  
 - Android应用程序的消息处理机制由消息循环、消息发送和消息处理三个部分。
 - Android应用程序的主线程进入消息循环过程前，或者内部创建一个Linux管道（Pipe），管道的作用是使得Android应用程序主线程消息在消息队列为空时可进入空闲等待状态，并且使得当应用程序的消息队列有消息要处理时唤醒应用程序的主线程，唤醒通过Linux的Epoll机制中的epoll_watiy函数进行的。
 - 当往Android应用程序的消息队列中加入新消息时，会同时往管道中的写端写入内容，通过这种方式就可以唤醒正在等待消息到来的应用程序主线程。
 - 当应用程序主线程进入空闲等待前，会任务当前线程处理空闲状态，于是就会调用那些已经注册了的IdeleHandler接口，使得应用程序有机会在空闲的时候处理一些事情。

 - 补充**anr**相关 **注意anr不是主线程卡住就触发，而是系统检测到主线程在规定时间内无法响应特定事件时才触发**   
 	1. 输入事件超时（activity）：触摸按键事件5s内未被处理。
	2. BoradcastReceiver 超时：前台广播10s，后台广播60s未执行完。
	3. Service超时：前台Service20s,后台Service200s未完成启动/绑定。

## 回顾整个过程：  
1. 准备Loop， 首先主线程（ActivityThread）main里面会调用Looper.prepareMainLooper()，在里面会在ThreadLocal(线程局部变量) 里面创建Loop对象，在Loop对象创建时会创建MessageQueue，保存为Looper的成员变量，后续消息就是存放在这个队列中。

2. 执行循环，Looper.loop() 循环从MessageQueue.next里面去取消息，当消息队列中没有消息,或者未到消息执行时间时会进入空闲等待，有消息时执行。（如果设置了IdealHandler会在第一次空闲时执行）

3. 发送消息，Handler.sendMessage -> enqueueMessage会查看是否延时Delayed，当延时时会取得当前消息执行的绝对时间，然后时间排序插入，设置**msg.target = this**,设置执行时间到**when**变量（循环时用到）（添加到消息队列时，如果是空闲状态调用唤醒）

4. dispatchMessage消息处理 使用msg.target.dispatchMessage去执行,target就是对应的handler



