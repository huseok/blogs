---
title: java 多线程
date: 2025-12-12
categories:
  - java
tags:
  - java
  - 多线程
---

# java 多线程

## 一、基础概念
1. 进程与线程   
      * 进程是操作系统进行资源分配和调度的基本单位，是程序的一次  执行过程，拥有独立的内存空间和系统资源。  
      * 线程是进程的一个执行单位，是CPU调度和分派的基本单位，线程本事不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、寄存器、栈），但它可与同属一个进程的其他线程共享进程所拥有的全部资源，一个进程可以包含多个线程。
2. **线程的生命周期和状态**
      * **初始状态（NEW）**：线程被创建出来但没有调用start()
      * **运行状态（RUNNABLE）** ：调用线程的star()方法等待运行的状态
      * **阻塞状态（BLOCKED）** ：阻塞状态，需要等待锁释放
      * **等待状态（WAITING）**：表示该线程需要等待其他线程做出一些特定动作（通知或中断）
      * **超时等待状态（TIME_WAITING）**：可以在知道的时间后资讯返回，而不是像WAITING那样一直等待。
      * **终止状态（TERMINATED）**：终止状态，表示该线程已经运行完毕。
![线程的状态图](/blogs/thread-state.png)

由上图可以看出：线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。  
当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。    
TIMED_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。      
当线程进入 synchronized 方法/块或者调用 wait 后（被 notify）重新进入 synchronized 方法/块，但是锁被其它线程占有，这个时候线程就会进入 BLOCKED（阻塞） 状态。    
线程在执行完了 run()方法之后将会进入到 TERMINATED（终止） 状态。    

3. 并发与并行
      * **并发**：指多个线程在同一时间段内交替执行，宏观上看起来多个线程在同时执行，但微观上是交替进行的，例如单CPU核心下多线程的执行。
      * **并行** ：指多个线程在同一时刻同时执行，需要多个CPU核心支持，每个核心处理一个线程，真正实现同时执行。

4. 为啥要使用多线程     
    提高单进程利用CPU和IO系统的效率，例如IO耗时但不占用CPU资源。

5. 多线程可能带来的问题     
    内存泄漏、死锁、线程不安全等。      
    * 线程不安全  
        指多线程环境下，同一份数据，多个线程同时访问时，可能导致数据混乱、错误或丢失。
    * **死锁**      
        多个线程同时被阻塞，它们中一个或全部都在等待某个资源释放。由于线程被无限阻塞导致程序不能正常终止。      
        **四个必要条件**    
            1. 互斥条件：该资源任意一个时刻只由一个线程占用。     
            2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。   
            3. 不剥夺条件：线程已获得的资源在未使用完之前，不能被其他线程强行剥夺，只有自己使用完毕后才能释放资源。   
            4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。   
        **如何检测**    
            1. 使用jmap、jstack等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，jstack 的输出中通常会有 Found one Java-level deadlock:的字样，后面会跟着死锁相关的线程信息。另外，实际项目中还可以搭配使用top、df、free等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高。   
            2. 采用 VisualVM、JConsole 等工具进行排查。

## 二、线程创建
1. 继承Thread类
2. 实现Runnable接口
3. 实现Callable接口
4. 使用线程池

Callable方式    
Callable的call()方法有返回值，且可抛出异常，创建**Callable**接口实现类的实例，使用**FutureTask**类来包装Callable对象，FutureTask对象可以获取线程执行的返回值。  

```java
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;
class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= 5; i++) {
            sum += i;
        }
        return sum;
    }
}
public class CallableTest {
    public static void main(String[] args) {
        MyCallable myCallable = new MyCallable();
        FutureTask<Integer> futureTask = new FutureTask<>(myCallable);
        Thread thread = new Thread(futureTask);
        thread.start();
        try {
            Integer result = futureTask.get();
            System.out.println("线程执行结果：" + result);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
线程池方式    
```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class ThreadPoolTest {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        for (int i = 0; i < 5; i++) {
            executorService.execute(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName() + "正在执行任务");
                }
            });
        }
        executorService.shutdown();
    }
}
```

## 三、 线程的常用方法
1. **start()** ：启动线程，使线程进入就绪状态，等待获取CPU资源后执行run()方法。
2. **run()** ： 线程的执行体，不能直接调用run()方法来启动线程，直接调用只是普通方法调用。
3. **sleep(long millis)**：让当前线程休眠知道的毫秒数，线程进入阻塞状态，休眠结束进入就绪，**sleep()方法不会释放对象的锁**
4. **join()**：等待该线程终止，调用join()方法的线程会进入阻塞状态，直到被调用的线程执行完毕后才会恢复就绪状态。
5. **yield()**：让当前线程主动让出CPU资源，回到就绪状态，可能立即被再次调度。
6. **interrupt()** ：中断线程（设置中断标志），需结合isInterrupted()或interrupted()处理。
```java 
Thread t = new Thread(() -> {
    while (!Thread.currentThread().isInterrupted()) {
        // 任务逻辑
    }
});
t.start();
t.interrupt(); // 中断线程
```
7. **getName()/setName(String name)**：获取/设置线程名称
8. **getPriority()/setPriority(int priority)** :线程优先级（1-10，默认5，优先级高的线程更可能被调度）
9. **isALive()** : 判断线程是否存活（已启动且未终止）
10. **isInterrupted**：判断线程是否被中断（不清除中断标志）
11. **interrupted()** ：静态方法，判断当前线程是否被中断（清除中断标志）
12. **currentThread()** ：静态方法，获取当前执行的线程对象。
13. **setDaemon()** ： 设置线程为守护线程，当所有非守护线程结束时，JVM自动退出，需在**start()前调用**

### 线程方法使用的注意事项：
1. 中断处理：通过interrupt()中断线程时，需在代码中检查中断状态并优雅退出。
2. 锁与sleep()：sleep() 不会释放同步锁，而wait()（Object类方法）会释放锁。
3. 守护线程：不能持有需要关闭的资源（如文件句柄），否则可能无法正常释放

## 四、 volatile 和synchronized 
### volatile        
volatile是一个**变量修饰符**，智能修饰实例变量或类变量（不能用于方法、局部变量），用于保证变量的**可见性**（一个线程修改了volatile变量值，会立即刷新到主内存，其他线程读取会从主内存加载）和**禁止指令重排**（保证指令执行顺序与代码逻辑顺序一致，如单例双重检查锁），但不保证**原子性**（如ABA问题）       
单例中使用      
```java
public class Singleton {
    private volatile static Singleton instance; // 禁止指令重排序

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) { // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) { // 第二次检查
                    instance = new Singleton(); // volatile防止指令重排序导致的半初始化对象问题
                }
            }
        }
        return instance;
    }
}
```
### synchronized
synchronized 是一个**同步关键字**，可修饰方法或代码块，用于实现**原子性**（同步块内的代码执行是原则的，不会被其他线程打断）、**可见性**和**有序性**，是java中的**互斥同步机制**。
会**隐形释放锁**，线程执行完同步代码或抛出异常时，会自动释放锁，避免死锁风险（相比Lock更加安全）。

1. **互斥性**：确保同一时刻只有一个线程能执行被synchroized修饰的代码（方法或代码块），其他线程需等待锁释放。
2. **可见性**：线程释放锁时，会将工作内存中的变量刷新到主内存，线程获取锁时，会清空工作内存并从主内存加载最新变量值。
3. **有序性**：通过“锁的获取-释放”规则，保证代码块内的指令执行顺序与逻辑顺序一致（锁内代码禁止重排序）。


#### synchronized实现原理
1. 修饰代码块：通过monitorenter（获取锁）和monitorexit（释放锁）指令实现，锁对象为代码块指定的对象（如this或类对象）。
2. 修饰实例对象：锁对象为当前实例（this）。
3. 修饰静态方法：锁对象为当前类的class对象。


### synchronized 偏向锁、轻量级锁、重量级锁的升级机制，优化性能
 * **偏向锁**：无竞争时，线程获取锁后标记为偏向自己，避免CAS操作。（后续版本默认废弃）
 * **轻量级锁**： 少量竞争时，通过CAS自旋获取锁，避免操作系统内核态切换。
 * **重量级锁**：竞争激烈时，挂起线程并通过操作系统互斥实现锁，性能较低但稳定。

### volatile 和 synchronized 对比

| **特性**         | **volatile**                          | **synchronized**                      |
|------------------|---------------------------------------|---------------------------------------|
| **修饰对象**     | 仅变量（实例变量/类变量）             | 方法、代码块                          |
| **原子性**       | 不保证（复合操作不安全）              | 保证（同步块内代码原子执行）          |
| **可见性**       | 保证                                  | 保证                                  |
| **有序性**       | 禁止指令重排序（变量级）              | 保证同步块内有序性（代码级）          |
| **锁机制**       | 无锁（轻量级）                        | 有锁（偏向锁/轻量级锁/重量级锁）      |
| **性能**         | 开销极小（仅内存屏障）                | 有锁竞争时开销较大（可能内核态切换）  |
| **使用场景**     | 状态标记、单例DCL、变量可见性         | 复合操作、临界区互斥、原子性保证      |

### 总结
- **volatile**是“轻量级同步”，适合变量级的可见性和有序性保证，无法解决原子性问题，性能开销低。
- **synchronized**是“重量级同步”，适合代码块/方法级的原子性、可见性和有序性保证，功能全面但有锁竞争时性能开销较高。

实际开发中，需根据场景选择：  
- 若仅需变量可见性（如开关），用`volatile`；  
- 若需原子性或代码块互斥，用`synchronized`（或`java.util.concurrent.locks.Lock`）；  
- 单例DCL需结合`volatile`（禁止指令重排序）和`synchronized`（互斥初始化）。

## ReentrantLock 
ReentrantLock 实现了 Lock接口，是一个可重入且独占式的锁，和synchronized关键字类似。不过ReentrantLock更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。
```java
public class ReentrantLock implements Lock, java.io.Serializable {}
```
ReentrantLock 里面有一个内部类Sync，Sync继承自AQS（AbstractQueuedSynchronized）,添加锁和释放锁的大部分操作实际都是在Sync中实现的。Sync 有公平锁FairSync和非公平锁NonfairSync两个子类。      

ReentrantLock默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。
```java
// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```
可以看出ReentrantLock的底层就是由AQS来实现的。      

### 公平锁和非公平锁区别
 * **公平锁** ：锁释放之后，先申请的线程先得到锁，性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。      
 * **非公平锁** ：锁被释放之后，是随机或者按照其他优先级排序的。性能更好，但可能导致某些线程永远无法获得到锁。

 ### synchronized 和 ReentrantLock 区别

`synchronized` 和 `ReentrantLock` 是 Java 中实现线程同步的两大核心机制，前者是 JVM 层面的原生关键字，后者是 JUC（`java.util.concurrent.locks`）包提供的显式锁实现。二者核心目标都是保证并发安全，但在**实现层面、功能特性、使用方式**上差异显著，以下从多维度详细对比：

#### 核心差异总览
| 特性                | synchronized                          | ReentrantLock                          |
|---------------------|---------------------------------------|----------------------------------------|
| 实现层面            | JVM 原生关键字，底层通过 monitor 监视器实现 | 基于 AQS（抽象队列同步器）的 Java 类实现 |
| 锁获取方式          | 隐式获取/释放（执行完代码块/抛异常自动释放） | 显式获取/释放（需手动调用 `lock()`/`unlock()`，建议在 `finally` 中释放） |
| 锁类型              | 仅非公平锁（JDK 1.6 后优化为偏向/轻量/重量级锁） | 支持公平锁/非公平锁（构造函数指定 `fair` 参数） |
| 可中断性            | 不可中断（线程获取锁时会一直阻塞，除非获取到锁） | 支持可中断（`lockInterruptibly()`）、超时获取（`tryLock(long timeout, TimeUnit unit)`） |
| 条件变量（Condition） | 不支持（仅能通过 Object 的 wait()/notify()） | 支持多个 Condition（`newCondition()`），可精准唤醒指定线程 |
| 锁尝试获取          | 无（要么阻塞，要么获取）| 支持非阻塞尝试（`tryLock()`），获取失败立即返回 false |
| 重入性              | 支持（同一线程可重复获取锁，自动记录重入次数） | 支持（显式重入，可通过 `getHoldCount()` 获取重入次数） |
| 性能                | JDK 1.6 后优化（偏向/轻量锁），与 ReentrantLock 接近 | 高并发下更灵活，可通过自旋减少阻塞开销 |
| 可扩展性            | 无（功能固定，无法自定义）| 可继承扩展（基于 AQS 自定义同步逻辑） |

#### 关键差异详解
##### 1. 实现与释放机制
- **synchronized**：  
  是 JVM 层面的语法糖，无需手动释放锁。线程进入同步块时自动获取 monitor 锁，退出同步块（或抛出异常）时自动释放锁，即使发生异常也不会导致锁泄漏，使用更“省心”。  
  底层通过 `monitorenter`/`monitorexit` 指令实现，依赖操作系统内核态的互斥量（重量级锁阶段），JDK 1.6 后引入偏向锁、轻量级锁优化，减少内核态切换开销。

- **ReentrantLock**：  
  是 Java 代码层面的显式锁，需手动调用 `lock()` 获取锁，`unlock()` 释放锁，且必须在 `finally` 块中释放（否则异常会导致锁永久持有，引发死锁）。  
  底层基于 AQS 实现，通过 CAS 操作管理同步状态（`state` 变量），结合 CLH 队列管理等待线程，逻辑更灵活。

  示例：
  ```java
  // ReentrantLock 正确使用方式
  ReentrantLock lock = new ReentrantLock();
  public void method() {
      lock.lock(); // 显式加锁
      try {
          // 临界区逻辑
      } finally {
          lock.unlock(); // 必须在finally释放
      }
  }
  ```

##### 2. 锁的公平性
- **synchronized**：  
  仅支持**非公平锁**。线程释放锁后，新请求锁的线程可能“插队”获取锁，而非严格按等待顺序，这是默认策略（兼顾性能）。

- **ReentrantLock**：  
  支持**公平锁/非公平锁**（默认非公平），通过构造函数指定：
  ```java
  ReentrantLock fairLock = new ReentrantLock(true); // 公平锁
  ReentrantLock nonFairLock = new ReentrantLock(false); // 非公平锁（默认）
  ```
  公平锁保证线程按“先到先得”获取锁，避免饥饿，但性能略低（需维护队列顺序）；非公平锁性能更高，但可能导致部分线程长期等待。

##### 3. 中断与超时机制
- **synchronized**：  
  不支持中断，也无超时机制。线程一旦进入阻塞等待锁的状态，只能被动等待获取锁或被其他线程唤醒，无法主动终止等待。

- **ReentrantLock**：  
  提供灵活的等待控制：
  - **可中断获取**：`lockInterruptibly()`，等待锁的线程可响应中断（调用 `thread.interrupt()` 终止等待）；
  - **超时获取**：`tryLock(long timeout, TimeUnit unit)`，指定时间内未获取到锁则返回 `false`，避免永久阻塞。

  示例（可中断锁）：
  ```java
  public void method() throws InterruptedException {
      lock.lockInterruptibly(); // 等待锁时可被中断
      try {
          // 临界区逻辑
      } finally {
          lock.unlock();
      }
  }

  // 超时获取锁
  if (lock.tryLock(1, TimeUnit.SECONDS)) { // 1秒内未获取则返回false
      try {
          // 临界区逻辑
      } finally {
          lock.unlock();
      }
  } else {
      // 获取锁失败的处理逻辑
  }
  ```

##### 4. 条件变量（Condition）
- **synchronized**：  
  依赖 `Object` 类的 `wait()`/`notify()`/`notifyAll()` 实现等待-唤醒，存在局限性：
  - 仅能绑定一个“等待队列”，`notifyAll()` 会唤醒所有等待线程，无法精准唤醒；
  - `wait()` 必须在同步块内调用，且唤醒顺序随机。

- **ReentrantLock**：  
  通过 `newCondition()` 创建多个 `Condition` 对象，每个 `Condition` 对应一个独立的等待队列，可实现精准唤醒：
  ```java
  ReentrantLock lock = new ReentrantLock();
  Condition condition1 = lock.newCondition();
  Condition condition2 = lock.newCondition();

  // 线程1等待
  lock.lock();
  try {
      condition1.await(); // 仅等待condition1的唤醒
  } finally {
      lock.unlock();
  }

  // 线程2唤醒指定线程
  lock.lock();
  try {
      condition1.signal(); // 仅唤醒等待condition1的线程
  } finally {
      lock.unlock();
  }
  ```

##### 5. 重入性
二者均支持**重入锁**（同一线程可重复获取同一把锁，避免死锁）：
- **synchronized**：JVM 自动记录重入次数，线程每次进入同步块，重入次数+1，退出时-1，次数为0时释放锁；
- **ReentrantLock**：通过 `state` 变量记录重入次数，可通过 `getHoldCount()` 主动获取重入次数，更透明。

#### 使用场景选择
| 场景                          | 推荐使用          | 原因                                   |
|-------------------------------|-------------------|----------------------------------------|
| 简单同步（如普通方法/代码块） | synchronized      | 语法简洁，无需手动释放，JVM 自动优化    |
| 公平锁需求                    | ReentrantLock     | synchronized 不支持公平锁              |
| 可中断/超时获取锁             | ReentrantLock     | synchronized 无此功能                  |
| 多条件精准唤醒                | ReentrantLock     | 支持多个 Condition，避免无效唤醒        |
| 高并发且需灵活控制锁          | ReentrantLock     | 可自定义锁逻辑，性能更可控             |
| 追求代码简洁性/低维护成本     | synchronized      | 减少手动释放锁的出错风险               |

#### 可中断锁和不可中断锁区别
 * **可中断锁**：获取锁的过程中可以被中断，不需要一直等到获取锁之后才能进行其他逻辑处理，ReentrantLock就属于可中断锁
 * **不可中断锁**：一旦线程申请了锁，就只能等拿到锁以后才能进行其他的逻辑处理，synchronized就属于不可中断锁

## ThreadLocal
通常情况我们创建的变量可以被任何一个线程访问和修改，多线程中可能导致数据竞争和线程安全问题，我们想让每个线程都有自己的专属本地变量，就可以使用到ThreadLocal     

在查看handler&Loop时就看到有使用ThreadLocal,将Loop作为线程局部变量，只知道使用，现在看下大致原理。      

在Thread源码中
```java
public class Thread implements Runnable {
    // ......
    // 与此线程有关的ThreadLocal值。由ThreadLocal类维护
    ThreadLocal.ThreadLocalMap threadLocals = null;
    // 与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
    // ......
}
static class ThreadLocalMap {
    static class Entry extends WeakReference<ThreadLocal<?>> {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal<?> k, Object v) {
            super(k);
            value = v;
        }
    }
}
```
Thread类有threadLocals和inheritableThreadLocals变量，都是ThreadLocalMap类型的变量，ThreadLocalMap静态内部类Entry,ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap,默认情况这两个都是null，当线程调用ThreadLocal类时创建他们，key 是弱引用，value是强引用，即使key被GC回收，value仍然被ThreadLocalMap.Entry强应用存在，无法被GC回收，可能导致内存泄露，使用完ThreadLocal后，务必调用remove()方法，这是最安全和推荐的避免内存泄漏的方法，在线程池复用场景下，使用try-finally块保证一定被执行，这里就不过多分析了。

## 线程池       

### 线程池的好处：

1. **降低资源消耗**： 线程池里的线程是可以重复利用的。一旦线程完成了某个任务，他不会立即销毁，而是回到池子里等待下一个任务。这就避免了频繁创建和销毁线程带来的开销。        
2. **提高响应速度**：因为线程池里通常会维护一定数量的核心线程，任务来了后，可以直接交给已存在、空闲的线程去执行，省去创建线程时间，更快得到处理。
3. **提高线程的可管理性**： 线程池运行我们统一管理池中的线程。我们可以配置线程池的大小（核心线程数、最大线程数）、任务队列的类型和大小、拒绝策略等。这样就能控制并发线程的总量，房子系统资源耗尽，保证系统的稳定性。同时，线程池通常也提供了监控接口，方便我们了解线程池的运行状态（比如有多少活跃现场，多少任务在排队等）,便于调优。

### 创建线程池的两种方式：
 * 一、通过 **ThreadPoolExecuter** 构造函数直接创建（推荐）
 * 二、通过 **Executors** 工具类创建（不推荐用于生产环境）

### Executors 工具类创建的几种线程池
* **FixedThreadPool** ：固定线程数量的线程池，该线程中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会暂存在一个任务队列中，待有现成空闲时，便处理在任务队列中的任务。        
* **SingleThreadExecutor** : 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。     
* **CachedThreadPool** : 可根据实际情况调整线程数量的线程池。线程池的线程数不确定，若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。     
* **ScheduledThreadPool** : 给定的延迟后运行任务或者定期执行任务的线程池。      

#### 不推荐内置线程池的原因
* **FixedThreadPool** 和 **SingleThreadExecutor** 使用的是阻塞队列 **LinkedBlockingQueue**,任务队列最大长度为**Integer.MAX_VALUE**，可以看做是无界的，可能堆积大量的请求，从而导致OOM。     
* **CachedThreadPool** 使用的是同步队列 **SynchronousQueue**，允许创建的线程数量为**Integer.MAX_VALUE**,如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致OOM。     
* **ScheduleThreadPool** 和 **SingleThreadScheduledExecutor** 使用的是无界的延迟阻塞队列 **DelayedWorkQueue**，任务队列最大长度为**Integer.MAX_VALUE**，可能堆积大量的请求，从而导致OOM。        

### 线程池常见的参数        

ThreadPoolExecutor 3个最重要的参数：        
* **corePoolSize**： 任务队列为达到队列容量时，最大可以同时运行的线程数量。     
* **maximumPoolSize** ： 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
* **workQueue** ：新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。      

ThreadPoolExecutor 其他常见参数：       

* **keepAliveTime** ：当线程池中的线程数量大于 **corePoolSize**，即有非核心线程时，这些非核心线程空闲后不会立即销毁，而是会等待，直到等待的时间超过了 **keepAliveTime** 才会被回收销毁。        
* **unit** ：**keepAliveTime** 参数的时间单位。      
* **threadFactory** ： executor创建新线程的时候会用到。
* **handler** ：拒绝策略

```java
    /**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */
    public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量
                              int maximumPoolSize,//线程池的最大线程数
                              long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间
                              TimeUnit unit,//时间单位
                              BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列
                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可
                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务
                               ) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```     

#### 核心线程空闲时状态        
* **设置了核心线程的存活时间**：核心线程空闲时，会处于 **WATING** 状态，如果阻塞等待时间超过核心线程存活时间，则该线程会退出工作，将该线程从线程池工作线程集合中移除，线程状态变为 **TERMINATED** 状态。        
* **没有设置核心线程存活时间**：核心线程空闲时，会一直处于**WATING** 状态，等待获取任务，核心线程会一直存活在线程池中。

#### 线程池的拒绝策略

如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放慢了任务时，ThreadPoolExecutor 定义了一些策略：     

* **ThreadPoolExecutor.AbortPolicy** ：抛出RejectedExecutionException 来拒绝新任务的处理。      
* **ThreadPoolExecutor.CallerRunPolicy** ：调用执行者自己的线程运行任务，也就是直接在调用execute方法的线程中运行（run）被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对新任务提交速度，影响程序的整体性能。如果你的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，可以选择这个策略。
* **ThreadPoolExecutor.DiscardPolicy** ：不处理新任务，直接丢弃掉。
* **ThreadPoolExecutor.DiscaardOledstPolicy** ： 此策略丢弃最早的未处理的任务请求。

#### 线程池常见的阻塞队列
* 容量为**Integer.MAX_VALUE** 的 **LinkedBlockingQueue** (**无界阻塞队列**)：**FixedThreadPool** 和 **SingleThreadExecutor** 。 FixedThreadPool 最多只能创建核心线程数的线程（核心线程数和最大线程数相等），SingleThreadExecutor 只能创建一个线程（核心线程数和最大线程数都是 1 ），二者的任务队列永远不会被放满。      
* **SynchronousQueue** (同步队列) ： CachedThreadPool 。 SynchronousQueue 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则空闲线程处理，没有则新建线程处理，CachedThreadPool 的最大线程数时 Integer.MAX_VALUE , 可以理解为线程数是可以无限扩展的，可能会创建大量的线程，从而导致OOM。     
* **DelayedWorkQueue**（延迟队列）： ScheduledThreadPool 和 SingleThreadScheduledExecutor。内部会按照延迟时间排序，内部采用“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。元素满了会自动扩容，扩容增加原来的50%，即永远不会阻塞，最大扩容可达Integer.MAX_VALUE,所以最多只能创建核心线程数的线程。        
* **ArrayBlockingQueue** (有界阻塞队列)：底层由数组实现，容量一旦创建，就不能修改。


## AQS（AbstractQueuedSynchronizer，抽象队列同步器）

AQS解决开发者实现同步器时的复杂性问题，提供了一个通用框架，用于实现各种同步器，例如：**可重入锁**（**ReentrantLock**）、**信号量**（**Semaphore**）和***倒计时器***（**CountDownLatch**）。通过封装底层的线程同步机制，AQS将复杂的线程管理逻辑隐藏起来，使开发者只需专注于具体的同步逻辑。      

简单来说AQS是一个抽象类，为同步器提供通用的**执行框架**。它定义了**资源获取和释放的通用流程**，而具体的资源获取逻辑则由具体同步器通过重写模板方法来实现。因此可以将AQS看作是同步器的**基础“底座”**，而同步器则是基于AQS实现的**具体“应用”**。

### AQS的原理。     

AQS 核心思想是 被请求的共享资源空闲，当前请求资源的线程设置为有效的工作线程，将资源设置为锁定状态。如果被请求的共享资源被占用，那就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是基于**CLH锁**进一步优化实现。

**CLH锁**对自选锁进行了改进，是基于单链表的自旋锁。在多线程场景下，会将请求获取的锁的线程组织成一个单向队列，每个等待的线程会通过自旋访问前一个线程节点的状态，前一个节点释放锁后，当前节点才可以获取到锁。CLH锁的队列结构图如下图所示：
![CLH锁队列结构](/blogs/clh.png)      

AQS的等待队列时CLH锁队列的变体，是一个双向队列，会将暂时获取不到锁的线程加入该队列中，AQS中CLH锁变体队列和CLH锁队列区别主要有两点：     
* 由**自旋**优化为**自旋+阻塞**：自旋操作性能高，但大量自旋比较占CPU资源，因此在CLH变体队列中会先通过自旋尝试获取锁，如果失败再进行阻塞等待。       
* 由**单向队列**优化为**双向队列**：在CLH变体队列中，会对等待的线程进行阻塞操作，当队列前边的线程释放锁后，需要对后边的线程进行唤醒，因此增加了next指针，成为了双向队列。

AQS将每条请求共享资源的线程封装成一个CLH变体队列的结点（Node）来实现锁的分配。在CLH变体队列中，一个节点表示一个线程，它保存着线程的引用、当前节点在队列中的状态（waitStatus）、前驱结点（prev）、后继结点（next）。 结构如下图所示      
![AQS中CLH变体队列结构图](/blogs/aqs-struct.png)      

核心原理如图        
![AQS中CLH变体队列核心原理图](/blogs/aqs-theory.png)      

AQS 使用 int 成员变量 state 表示同步状态，通过内置的 线程等待队列 来完成获取资源线程的排队工作。

`state` 变量由 `volatile` 修饰，用于展示当前临界资源的获锁情况。        
状态信息 `state` 可以通过`getState()`、`setState()` 和 `compareAndSetState()` 进行操作。由final修饰，子类无法重写。     
```java
// 共享变量，使用volatile修饰保证线程可见性
private volatile int state;
//返回同步状态的当前值
protected final int getState() {
     return state;
}
 // 设置同步状态的值
protected final void setState(int newState) {
     state = newState;
}
//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）
protected final boolean compareAndSetState(int expect, int update) {
      return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}

``` 

以 **ReentrantLock** 为例，`state` 初始为 0 ,表示未锁定，A线程 `lock()`时，会调用`tryAcquire()`独占该锁并将 `state+1` 。其他线程再 `tryAcquire()` 时就会失败，直到A线程`unlock()` 到`state = 0` 为止（释放锁），其他线程才有机会获取锁。释放锁前，A线程可以重复获取锁，state累加，这就是可重入概念。但要注意，获取多少次就需要释放多少次，才能保证state 能回到零态。        

以 **CountDownLatch** 为例，任务分给N个子线程执行，`state`初始为N 。N个子线程并行执行，每个子线程完成后`countDown()`一次，state会CAS减1。 等到所有子线程执行完，state=0，会`unpark()`主调用线程，然后主调用线程就会从 await()函数返回，继续后续动作。

CountDownLatch,倒数
CylicBarrier,公交、栅栏 ，数量达到count时开始执行
Semaphore，信号










































